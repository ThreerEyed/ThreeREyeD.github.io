<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>threereyed</title>
  <icon>https://www.gravatar.com/avatar/b8e5319dcf81fce2fe0939fe5e85735b</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://threereyed.top/"/>
  <updated>2020-05-28T08:12:19.931Z</updated>
  <id>http://threereyed.top/</id>
  
  <author>
    <name>threereyed</name>
    <email>2622509069@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言基础学习day04</title>
    <link href="http://threereyed.top/2020/05/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0day04/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day04/"/>
    <id>http://threereyed.top/2020/05/27/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0day04/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day04/</id>
    <published>2020-05-27T14:31:21.000Z</published>
    <updated>2020-05-28T08:12:19.931Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">            <p>本节内容承接上节内容<a href="https://threereyed.top/2020/05/26/Go语言学习day03/Go语言基础学习day03/">Go语言基础学习day03</a>，关于Go语言的基础学习</p>          </div><div class="note warning">            <p>这是一个创建于 2020-05-27 22:31:21 的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Go 语言提供了数组类型的数据结构。</p><p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。</p><p>数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。</p><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">3</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>初始化数组中 {} 中的元素个数不能大于 [] 中的数字。</p><p>如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>初始化数组的初始化有多种形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为5的数组，其元素值依次为：1，2，3，4，5。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为 5 的数组，其元素值依次为：1，2，0，0，0 。</p><p>在初始化时没有指定初值的元素将会赋值为其元素类型 int 的默认值0，string 的默认值是 “”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为 5 的数组，其长度是根据初始化时指定的元素个数决定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>] <span class="keyword">int</span> &#123; <span class="number">2</span>:<span class="number">1</span>,<span class="number">3</span>:<span class="number">2</span>,<span class="number">4</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为 5 的数组，key:value，其元素值依次为：0，0，1，2，3。在初始化时指定了 2，3，4 索引中对应的值：1，2，3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...] <span class="keyword">int</span> &#123;<span class="number">2</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为5的数组，起元素值依次为：0，0，1，0，3。由于指定了最大索引 4 对应的值 3，根据初始化的元素个 数确定其长度为5赋值与使用。</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.<span class="built_in">println</span>(array[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是由数组引出的，因为数组的长度是固定不变的，有的时候我们需要一个可变的元素集合，这个时候就有了动态数组，也就是切片。</p><p>内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><p>切片由三部分组成：指向底层数组的指针、len、cap。</p><h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><p>切片有两种定义方式</p><h4 id="声明一个没有大小的数组来定义切片"><a href="#声明一个没有大小的数组来定义切片" class="headerlink" title="声明一个没有大小的数组来定义切片"></a>声明一个没有大小的数组来定义切片</h4><p>不需要说明长度[] 内没有数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h4 id="使用make-函数来定义"><a href="#使用make-函数来定义" class="headerlink" title="使用make() 函数来定义"></a>使用<code>make()</code> 函数来定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">slice1 :=  <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> makeSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">var</span> makeSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(makeSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>[0 0 0 0 0]</p></blockquote><h3 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:]</span><br></pre></td></tr></table></figure><p>初始化切片s, 是数组arr的引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:]</span><br></pre></td></tr></table></figure><p>默认 endIndex 时将表示一直到arr的最后一个元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex]</span><br></pre></td></tr></table></figure><p>默认 startIndex 时将表示从arr的第一个元素开始</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>通过切片s初始化切片s1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>注意： </p><p>切片有两种方式，一种是make创建或者声明[]int，另一种是通过数组切片获得，切片是对数组的引用，采用的是引用传递，当给切片赋值后，底层的数组也会发生改变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> makeSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(makeSlice)</span><br><span class="line"></span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"a 的类型是%T\n"</span>, a)</span><br><span class="line"></span><br><span class="line">b := a[:]</span><br><span class="line">fmt.Printf(<span class="string">"b 的类型是%T, 值是%v\n"</span>, b, b)</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"b 的类型是%T, 值是%v\n"</span>, b, b)</span><br><span class="line">fmt.Printf(<span class="string">"a 的类型是%T, 值是%v\n"</span>, a, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>[0 0 0 0 0]<br>a 的类型是[5]int<br>b 的类型是[]int, 值是[1 2 3 4 5]<br>b 的类型是[]int, 值是[10 2 3 4 5]<br>a 的类型是[5]int, 值是[10 2 3 4 5]</p></blockquote><h3 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h3><p>切片是可索引的，并且可以由 len() 方法获取长度。</p><p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lenth := <span class="built_in">len</span>(b)</span><br><span class="line">capB := <span class="built_in">cap</span>(b)</span><br><span class="line">fmt.Printf(<span class="string">"len(b)=%v, cap(b)=%v\n"</span>, lenth, capB)</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>len(b)=5, cap(b)=5</p></blockquote><h3 id="空的切片"><a href="#空的切片" class="headerlink" title="空的切片"></a>空的切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c []<span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">"c 的类型是%T，值是%v"</span>, c, c)</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>c 的类型是[]int，值是[]</p></blockquote><h3 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h3><p>切片的底层是数组，基于数组构建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers =="</span>, numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers[1:4] =="</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers[:3] =="</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers[4:] =="</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]<br>numbers == [0 1 2 3 4 5 6 7 8]<br>numbers[1:4] == [1 2 3]<br>numbers[:3] == [0 1 2]<br>numbers[4:] == [4 5 6 7 8]<br>len=0 cap=5 slice=[]<br>len=2 cap=9 slice=[0 1]<br>len=3 cap=7 slice=[2 3 4]</p></blockquote><p>注意：</p><p>在以上代码中我们发现最后一个number3 的输出和cap 发现cap发生改变，这是go的切片特性，在从索引0以后进行切片时，容量会发生改变，改变值取决于索引从哪开始 </p><h3 id="append-和-copy-函数"><a href="#append-和-copy-函数" class="headerlink" title="append() 和 copy() 函数"></a>append() 和 copy() 函数</h3><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p><p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>len=0 cap=0 slice=[]<br>len=1 cap=1 slice=[0]<br>len=2 cap=2 slice=[0 1]<br>len=5 cap=6 slice=[0 1 2 3 4]<br>len=5 cap=12 slice=[0 1 2 3 4]</p></blockquote><p>对于同时添加多个元素之后，我们发现初始切片的容量发生了改变，而且这个改变似乎有迹可循，这里对于append 多个元素这里有些规则</p><h4 id="添加较少的元素，一次性只添加一个元素"><a href="#添加较少的元素，一次性只添加一个元素" class="headerlink" title="添加较少的元素，一次性只添加一个元素"></a>添加较少的元素，一次性只添加一个元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    a = <span class="built_in">append</span>(a, i)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(a), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 4 4 8 8 8 8 16 16 16 16 16 16 16 16</span></span><br></pre></td></tr></table></figure><h4 id="一次性添加多个元素"><a href="#一次性添加多个元素" class="headerlink" title="一次性添加多个元素"></a>一次性添加多个元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(a), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6 12 24 24 48 48 48 48 48 96 96 96 96 96 96 96</span></span><br><span class="line"></span><br><span class="line">c := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">d := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"len(c)=%v, cap(c)=%v, %v\n"</span>, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c), c)</span><br><span class="line">c = <span class="built_in">append</span>(c, d...)</span><br><span class="line">fmt.Printf(<span class="string">"len(c)=%v, cap(c)=%v, %v\n"</span>, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="comment">// len(c)=9, cap(c)=10, [1 3 1 2 3 4 5 6 7]</span></span><br></pre></td></tr></table></figure><p>如上代码所示，当我们初始化一个空的切片，然后不断使用append 向其中添加元素，然后查看切片a的容量改变，可以发现，在容量未满之前，容量不变</p><p>但是不同的元素类型会有不同的扩容情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int8</span></span><br><span class="line">a := []<span class="keyword">int8</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(a), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8 16 32 32 32 64 64 64 64 64 128 128 128 128 128 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int16</span></span><br><span class="line">fmt.Println()</span><br><span class="line">b := []<span class="keyword">int16</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    b = <span class="built_in">append</span>(b, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(b), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8 16 32 32 32 64 64 64 64 64 128 128 128 128 128 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bool</span></span><br><span class="line">fmt.Println()</span><br><span class="line">c := []<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    c = <span class="built_in">append</span>(c, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(c), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8 16 32 32 32 64 64 64 64 64 128 128 128 128 128 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float32</span></span><br><span class="line">fmt.Println()</span><br><span class="line">d := []<span class="keyword">float32</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    d = <span class="built_in">append</span>(d, <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(d), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8 16 16 32 32 32 64 64 64 64 64 64 128 128 128 128 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float64</span></span><br><span class="line">fmt.Println()</span><br><span class="line">e := []<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    e = <span class="built_in">append</span>(e, <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(e), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6 12 24 24 48 48 48 48 48 96 96 96 96 96 96 96 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line">fmt.Println()</span><br><span class="line">f := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    f = <span class="built_in">append</span>(f, <span class="string">"1.1"</span>, <span class="string">"2.2"</span>, <span class="string">"3.3"</span>, <span class="string">"4.4"</span>, <span class="string">"5.5"</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(f), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 10 20 20 40 40 40 40 80 80 80 80 80 80 80 80 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// []int</span></span><br><span class="line">fmt.Println()</span><br><span class="line">g := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">g1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    g = <span class="built_in">append</span>(g, g1, g1, g1, g1, g1)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(g), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 10 20 20 42 42 42 42 85 85 85 85 85 85 85 85</span></span><br></pre></td></tr></table></figure><p>以上关于append 的代码来源于<a href="https://www.jianshu.com/p/54be5b08a21c" target="_blank" rel="noopener">吴子寒的博客</a></p><p>关于append 的扩容策略，还请参照源码，网上诸多答案，再加上我自行测试之后，发现都不是很正确，总有不对的地方，所以只能通过源码来看底层策略是如何做的，初学者应该把更多的时间花在其他的方面</p><h4 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy() 函数"></a>copy() 函数</h4><p>copy 函数可以将一个sliece 复制给另一个slice</p><p><strong>数组切片内容复制</strong></p><p>用于将内容从一个数组切片复制到另一个数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice1 :&#x3D; []int&#123;1, 2, 3, 4, 5&#125; </span><br><span class="line">slice2 :&#x3D; []int&#123;5, 4, 3&#125; </span><br><span class="line"></span><br><span class="line">copy(slice2, slice1) &#x2F;&#x2F; 只会复制slice1的前3个元素到slice2中 </span><br><span class="line">copy(slice1, slice2) &#x2F;&#x2F; 只会复制slice2的3个元素到slice1的前3个位置</span><br></pre></td></tr></table></figure><p>copy 函数会创建一个新的数组</p><div class="note warning">            <p>本节部分内容来源于<a href="https://www.runoob.com/go/go-arrays.html" target="_blank" rel="noopener">菜鸟教程</a></p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day03</title>
    <link href="http://threereyed.top/2020/05/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0day03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day03/"/>
    <id>http://threereyed.top/2020/05/26/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0day03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day03/</id>
    <published>2020-05-26T10:03:31.000Z</published>
    <updated>2020-05-27T12:32:45.504Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">            <p>本节内容承接上节内容<a href="https://threereyed.top/2020/05/25/Go语言学习day02/Go语言基础学习day02/">Go语言基础学习day02</a>，关于Go语言的基础学习</p>          </div><div class="note warning">            <p>这是一个创建于 2020-05-26 18:03:31 的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>golang是一种强类型语言，虽然在代码中经常看到这种写法，<code>i:=10</code>这其实这是编译器自动做了类型推断在编译期间。编译器会对数据进行类型检查。不同类型的数据不能赋值,不能在函数中传参。强类型语言有一些优势，很多的错误会在编译期间被检查出来，不想php和python等弱类型语言，很多错误只有运行到才能被发现。同样，强类型也有一些缺点，写代码的时候要考虑数据类型了，失去了一些灵活性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.6</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Println (a * b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码会报错，因为类型不匹配<br>这时候需要强制类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.6</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Println (a * <span class="keyword">float32</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不会报错了<br>普通变量类型<strong>int,float,string</strong> 都可以使用 <code>type (a)</code>这种形式来进行强制类型转换,比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int32</span>  = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="keyword">int64</span>(a)</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = <span class="number">12.3</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">float64</span> =<span class="keyword">float64</span>(c)</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="go语言条件语句"><a href="#go语言条件语句" class="headerlink" title="go语言条件语句"></a>go语言条件语句</h3><p>条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句</p><table><thead><tr><th align="left">语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-if-statement.html" target="_blank" rel="noopener">if 语句</a></td><td align="left"><strong>if 语句</strong> 由一个布尔表达式后紧跟一个或多个语句组成。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-if-else-statement.html" target="_blank" rel="noopener">if…else 语句</a></td><td align="left"><strong>if 语句</strong> 后可以使用可选的 <strong>else 语句</strong>, else 语句中的表达式在布尔表达式为 false 时执行。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-nested-if-statements.html" target="_blank" rel="noopener">if 嵌套语句</a></td><td align="left">你可以在 <strong>if</strong> 或 <strong>else if</strong> 语句中嵌入一个或多个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-switch-statement.html" target="_blank" rel="noopener">switch 语句</a></td><td align="left"><strong>switch</strong> 语句用于基于不同条件执行不同动作。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-select-statement.html" target="_blank" rel="noopener">select 语句</a></td><td align="left"><strong>select</strong> 语句类似于 <strong>switch</strong> 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</td></tr></tbody></table><blockquote><p>注意：Go 没有三目运算符，所以不支持 <strong>?:</strong> 形式的条件判断。</p></blockquote><p><strong>f 语句使用 tips</strong>：</p><p><strong>（1）</strong> 不需使用括号将条件包含起来</p><p><strong>（2）</strong> 大括号{}必须存在，即使只有一行语句</p><p><strong>（3）</strong> 左括号必须在if或else的同一行</p><p><strong>（4）</strong> 在if之后，条件语句之前，可以添加变量初始化语句，使用；进行分隔，并且该变量只作用于该if 条件语句中（作用域）</p><p><strong>（5）</strong> 在有返回值的函数中，最终的return不能在条件语句中</p><h3 id="go-语言循环语句"><a href="#go-语言循环语句" class="headerlink" title="go 语言循环语句"></a>go 语言循环语句</h3><p>Go 语言提供了以下几种类型循环处理语句：</p><table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-for-loop.html" target="_blank" rel="noopener">for 循环</a></td><td align="left">重复执行语句块</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-nested-loops.html" target="_blank" rel="noopener">循环嵌套</a></td><td align="left">在 for 循环中嵌套一个或多个 for 循环</td></tr></tbody></table><p>使用for 循环打印九九乘法表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 打印九九乘法表</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i+<span class="number">1</span>; j++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%dx%d=%d "</span>, j, i, i*j)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>1x1=1<br>1x2=2 2x2=4<br>1x3=3 2x3=6 3x3=9<br>1x4=4 2x4=8 3x4=12 4x4=16<br>1x5=5 2x5=10 3x5=15 4x5=20 5x5=25<br>1x6=6 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36<br>1x7=7 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49<br>1x8=8 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64<br>1x9=9 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81</p></blockquote><p>程序理解：</p><p>程序自伤而下运行，当执行到外层for 循环的时候，设置变量i 初始值为1，如果 i &lt; 10 则在本次循环结束之后递增加1，i++ 是在本次循环执行语句完成之后再执行，给定 j 初始值为1，此时1 &lt; 1 + 1成立，执行语句输出，1 x 1 = 1，然后内层for循环的j 再加 1，此时 2 &lt; 1 + 1 不成立，跳出内层for循环，打印换行，再执行外层循环，此时的i == 2，然后依次执行…..</p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句可以控制循环体内语句的执行过程。</p><p>GO 语言支持以下几种循环控制语句：</p><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-break-statement.html" target="_blank" rel="noopener">break 语句</a></td><td align="left">经常用于中断当前 for 循环或跳出 switch 语句</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-continue-statement.html" target="_blank" rel="noopener">continue 语句</a></td><td align="left">跳过当前循环的剩余语句，然后继续进行下一轮循环。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-goto-statement.html" target="_blank" rel="noopener">goto 语句</a></td><td align="left">将控制转移到被标记的语句。</td></tr></tbody></table><p>break：跳出本层循环，继续往下执行循环之外的代码</p><p>continue：跳出本次循环，执行本层循环的下一次循环</p><p>goto：跳出多层循环，跳到指定label（标签）</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符用于在程序运行时执行数学或逻辑运算。</p><p>Go 语言内置的运算符有：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">相加</td><td align="left">A + B 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">相减</td><td align="left">A - B 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">相乘</td><td align="left">A * B 输出结果 200</td></tr><tr><td align="left">/</td><td align="left">相除</td><td align="left">B / A 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">求余</td><td align="left">B % A 输出结果 0</td></tr><tr><td align="left">++</td><td align="left">自增</td><td align="left">A++ 输出结果 11</td></tr><tr><td align="left">–</td><td align="left">自减</td><td align="left">A– 输出结果 9</td></tr></tbody></table><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">检查两个值是否相等，如果相等返回 True 否则返回 False。</td><td align="left">(A == B) 为 False</td></tr><tr><td align="left">!=</td><td align="left">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td><td align="left">(A != B) 为 True</td></tr><tr><td align="left">&gt;</td><td align="left">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &gt; B) 为 False</td></tr><tr><td align="left">&lt;</td><td align="left">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &lt; B) 为 True</td></tr><tr><td align="left">&gt;=</td><td align="left">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &gt;= B) 为 False</td></tr><tr><td align="left">&lt;=</td><td align="left">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &lt;= B) 为 True</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。</td><td align="left">(A &amp;&amp; B) 为 False</td></tr><tr><td align="left">||</td><td align="left">逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。</td><td align="left">(A || B) 为 True</td></tr><tr><td align="left">!</td><td align="left">逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。</td><td align="left">!(A &amp;&amp; B) 为 True</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。</p><p>下表列出了位运算符 &amp;, |, 和 ^ 的计算：</p><table><thead><tr><th align="left">p</th><th align="left">q</th><th align="left">p &amp; q</th><th align="left">p | q</th><th align="left">p ^ q</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr></tbody></table><p>Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td><td align="left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符”|”是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td><td align="left">(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td align="left">(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td align="left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</td><td align="left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>下表列出了所有Go语言的赋值运算符。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td align="left">C = A + B 将 A + B 表达式结果赋值给 C</td></tr><tr><td align="left">+=</td><td align="left">相加后再赋值</td><td align="left">C += A 等于 C = C + A</td></tr><tr><td align="left">-=</td><td align="left">相减后再赋值</td><td align="left">C -= A 等于 C = C - A</td></tr><tr><td align="left">*=</td><td align="left">相乘后再赋值</td><td align="left">C *= A 等于 C = C * A</td></tr><tr><td align="left">/=</td><td align="left">相除后再赋值</td><td align="left">C /= A 等于 C = C / A</td></tr><tr><td align="left">%=</td><td align="left">求余后再赋值</td><td align="left">C %= A 等于 C = C % A</td></tr><tr><td align="left">&lt;&lt;=</td><td align="left">左移后赋值</td><td align="left">C &lt;&lt;= 2 等于 C = C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt;=</td><td align="left">右移后赋值</td><td align="left">C &gt;&gt;= 2 等于 C = C &gt;&gt; 2</td></tr><tr><td align="left">&amp;=</td><td align="left">按位与后赋值</td><td align="left">C &amp;= 2 等于 C = C &amp; 2</td></tr><tr><td align="left">^=</td><td align="left">按位异或后赋值</td><td align="left">C ^= 2 等于 C = C ^ 2</td></tr><tr><td align="left">|=</td><td align="left">按位或后赋值</td><td align="left">C |= 2 等于 C = C | 2</td></tr></tbody></table><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>下表列出了Go语言的其他运算符。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">返回变量存储地址</td><td align="left">&a; 将给出变量的实际地址。</td></tr><tr><td align="left">*</td><td align="left">指针变量。</td><td align="left">*a; 是一个指针变量</td></tr></tbody></table><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">float32</span></span><br><span class="line">  <span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">  */\* 运算符实例 \*<span class="comment">/*</span></span><br><span class="line"><span class="comment">  fmt.Printf("第 1 行 - a 变量类型为 = %T\n", a );</span></span><br><span class="line"><span class="comment">  fmt.Printf("第 2 行 - b 变量类型为 = %T\n", b );</span></span><br><span class="line"><span class="comment">  fmt.Printf("第 3 行 - c 变量类型为 = %T\n", c );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span>\*  &amp; 和 \* 运算符实例 \*<span class="comment">/*</span></span><br><span class="line"><span class="comment">  ptr = &amp;a   */</span>\* <span class="string">'ptr'</span> 包含了 <span class="string">'a'</span> 变量的地址 \*<span class="comment">/*</span></span><br><span class="line"><span class="comment">  fmt.Printf("a 的值为  %d\n", a);</span></span><br><span class="line"><span class="comment">  fmt.Printf("*ptr 为 %d\n", *ptr);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>以上实例运行结果：</p><blockquote><p>第 1 行 - a 变量类型为 = int<br>第 2 行 - b 变量类型为 = int32<br>第 3 行 - c 变量类型为 = float32<br>a 的值为  4<br>*ptr 为 4</p></blockquote><p>指针变量 <strong>*** 和地址值 **&amp;</strong> 的区别：指针变量保存的是一个地址值，会分配独立的内存来存储一个整型数字。当变量前面有 <strong>*** 标识时，才等同于 **&amp;</strong> 的用法，否则会直接输出一个整型数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line">   <span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line">   ptr = &amp;a</span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"a的值为"</span>, a);    <span class="comment">// 4</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"*ptr为"</span>, *ptr);  <span class="comment">// 4</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"ptr为"</span>, ptr);    <span class="comment">// 824633794744</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><table><thead><tr><th align="left">优先级</th><th align="left">运算符</th></tr></thead><tbody><tr><td align="left">5</td><td align="left">* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td></tr><tr><td align="left">4</td><td align="left">+ - | ^</td></tr><tr><td align="left">3</td><td align="left">== != &lt; &lt;= &gt; &gt;=</td></tr><tr><td align="left">2</td><td align="left">&amp;&amp;</td></tr><tr><td align="left">1</td><td align="left">||</td></tr></tbody></table><p>当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是基本的代码块，用于执行一个任务。</p><p>Go 语言最少有个 main() 函数。</p><p>你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。</p><p>函数声明告诉了编译器函数的名称，返回类型，和参数。</p><p>Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。</p><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>Go 语言函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义解析：</p><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">result = a + b</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">result = a + b</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">result = addNum(a, b)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>300</p></blockquote><h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><p>Go 函数可以返回多个值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a, b := swap(<span class="string">"Google"</span>, <span class="string">"Runoob"</span>)</span><br><span class="line">  fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数如果使用参数，该变量可称为函数的形参。</p><p>形参就像定义在函数体内的局部变量。</p><p>调用函数，可以通过两种方式来传递参数：</p><table><thead><tr><th align="left">传递类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-function-call-by-value.html" target="_blank" rel="noopener">值传递</a></td><td align="left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-function-call-by-reference.html" target="_blank" rel="noopener">引用传递</a></td><td align="left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td></tr></tbody></table><p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p><hr><h3 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h3><table><thead><tr><th align="left">函数用法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-function-as-values.html" target="_blank" rel="noopener">函数作为另外一个函数的实参</a></td><td align="left">函数定义后可作为另外一个函数的实参数传入</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-function-closures.html" target="_blank" rel="noopener">闭包</a></td><td align="left">闭包是匿名函数，可在动态编程中使用</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-method.html" target="_blank" rel="noopener">方法</a></td><td align="left">方法就是一个包含了接受者的函数</td></tr></tbody></table><div class="note warning">            <p>本节内容引自<a href="https://www.runoob.com/go/go-decision-making.html" target="_blank" rel="noopener">菜鸟教程</a> </p>          </div>]]></content>
    
    <summary type="html">
    
      关于Go语言的基础学习
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day02</title>
    <link href="http://threereyed.top/2020/05/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0day02/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day02/"/>
    <id>http://threereyed.top/2020/05/25/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0day02/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day02/</id>
    <published>2020-05-25T01:57:50.000Z</published>
    <updated>2020-05-27T12:31:25.851Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">            <p>本节内容承接上节内容<a href="https://threereyed.top/2020/05/20/Go语言学习day01/Go语言基础学习day01/">Go语言基础学习day01</a>，关于Go语言的基础学习</p>          </div><div class="note warning">            <p>这是一个创建于 2020-05-25 的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><h2 id="Go语言关键字"><a href="#Go语言关键字" class="headerlink" title="Go语言关键字"></a>Go语言关键字</h2><h3 id="go的25个关键字"><a href="#go的25个关键字" class="headerlink" title="go的25个关键字"></a>go的25个关键字</h3><p>break default func interface select<br>case defer go map struct<br>chan else goto package switch<br>const fallthrough if range type<br>continue for import return var</p><h3 id="关键词解释"><a href="#关键词解释" class="headerlink" title="关键词解释"></a>关键词解释</h3><p>1.break：break 用于跳出循环<br>2.default：用于选择结构的默认选项（switch、select）<br>3.func：函数定义<br>4.interface：定义接口<br>5.select：go语言特有的channel选择结构<br>6.case：选择结构标签<br>7.chan：定义channel<br>8.const：常量<br>9.continue：跳过本次循环<br>10.defer：延迟执行内容（收尾工作）有点类似C++的析构，但是它是再函数结尾的时候去执行（也就是栈即将被释放的时候）<br>11.go：并发执行<br>12.map：map类型<br>13.struct：定义结构体<br>14.else：选择结构<br>15.goto：跳转语句<br>16.package：包<br>17.switch：选择结构<br>18.fallthrough：如果case带有fallthrough，程序会继续执行下一条case,不会再判断下一条case的值<br>19.if：选择结构<br>20.range：从slice、map等结构中取元素<br>21.type：定义类型<br>22.for：循环<br>23.import：导入包<br>24.return：返回<br>25.var：定义变量</p><h3 id="go的保留字"><a href="#go的保留字" class="headerlink" title="go的保留字"></a>go的保留字</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">Types:    <span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span>  </span><br><span class="line"><span class="keyword">uint</span>  <span class="keyword">uint8</span>  <span class="keyword">uint16</span>  <span class="keyword">uint32</span>  <span class="keyword">uint64</span>  <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">float32</span>  <span class="keyword">float64</span>  <span class="keyword">complex128</span>  <span class="keyword">complex64</span></span><br><span class="line"><span class="keyword">bool</span>  <span class="keyword">byte</span>  <span class="keyword">rune</span>  <span class="keyword">string</span>  error</span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line"><span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line"><span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><p>Go 语言按类别有以下几种数据类型：</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td></tr><tr><td align="left">2</td><td align="left"><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td></tr><tr><td align="left">3</td><td align="left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td></tr><tr><td align="left">4</td><td align="left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型</td></tr></tbody></table><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td></tr><tr><td align="left">2</td><td align="left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td></tr><tr><td align="left">3</td><td align="left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td align="left">4</td><td align="left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td align="left">5</td><td align="left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td></tr><tr><td align="left">6</td><td align="left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td align="left">7</td><td align="left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="left">8</td><td align="left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td></tr><tr><td align="left">2</td><td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td></tr><tr><td align="left">3</td><td align="left"><strong>complex64</strong> 32 位实数和虚数</td></tr><tr><td align="left">4</td><td align="left"><strong>complex128</strong> 64 位实数和虚数</td></tr></tbody></table><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>同python 语言不太一样，go语言中的布尔型true 和 false不等于0 和 1，在python 中，True  == 1 False == 0</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>go语言中的字符串是由双引号包含的，单引号包含的是int32 类型，不是字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'b'</span></span><br><span class="line">fmt.Println(reflect.TypeOf(a).Kind())</span><br><span class="line"></span><br><span class="line">b := <span class="string">"threereyed"</span></span><br><span class="line">fmt.Println(reflect.TypeOf(b).Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出为</p><blockquote><p>int32<br>string</p></blockquote><h3 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h3><p><strong>（1）func HasPrefix(s, prefix string) bool</strong></p><p>判断字符串s是否有前缀字符串prefix</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">"threereyed"</span></span><br><span class="line"><span class="comment">// 判断字符串中是否以指定字符串开头</span></span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">"th"</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">"ht"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>true</p><p>false</p></blockquote><p><strong>（2）func HasSuffix(s, suffix string) bool</strong></p><p>判断字符串s是否有后缀字符串suffix</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串中是否以指定字符串结尾</span></span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">"ed"</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">"sa"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>ture</p><p>false</p></blockquote><p><strong>（3）func Contains(s, substr string) bool</strong></p><p>判断字符串s是否包含子串substr</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串中是否包含某个字符串</span></span><br><span class="line">fmt.Println(strings.Contains(a, <span class="string">"ree"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>true</p></blockquote><p><strong>（4）func Count(s, sep string) int</strong></p><p>返回字符串s有几个不重复sep子串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串中有几个指定的字符串</span></span><br><span class="line">fmt.Println(strings.Count(a, <span class="string">"e"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>4</p></blockquote><p><strong>（5）func Index(s, sep string) int</strong></p><p>返回字符串s中子串sep第一次出现的位置；不存在返回-1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串中指定字符串第一次出现的位置</span></span><br><span class="line">fmt.Println(strings.Index(a, <span class="string">"e"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>3</p></blockquote><p><strong>（6）func ToLower(s string) string</strong></p><p>返回字符串s转小写的拷贝；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="string">"ThreeREyeD"</span></span><br><span class="line"><span class="comment">// 返回转小写后的字符串</span></span><br><span class="line">fmt.Println(strings.ToLower(b))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>threereyed</p></blockquote><p><strong>（7）func ToUpper(s string) string</strong></p><p>返回字符串s转大写的拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回转大写后的字符串</span></span><br><span class="line">fmt.Println(strings.ToUpper(b))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>THREEREYED</p></blockquote><p><strong>（8）func Repeat(s string, count int) string</strong></p><p>返回count个字符串s串联的字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将输入的字符串以指定的重复次数拼接后返回</span></span><br><span class="line">fmt.Println(strings.Repeat(b, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>ThreeREyeDThreeREyeDThreeREyeD</p></blockquote><p><strong>（9）func Replace(s, old, new string, n int) string</strong></p><p>返回字符串s前n个不重复old子串替换为new子串的新字符串；n&lt;0替换所有old子串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换字符串中的子字符串，当替换次数小于0的时候替换所有的子字符串</span></span><br><span class="line">fmt.Println(strings.Replace(b, <span class="string">"e"</span>, <span class="string">"T"</span>, <span class="number">1</span>))</span><br><span class="line">fmt.Println(strings.Replace(b, <span class="string">"e"</span>, <span class="string">"T"</span>, <span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>ThrTeREyeD<br>ThrTTREyTD</p></blockquote><p><strong>（10）func Trim(s string, cutset string) string</strong></p><p>返回去掉字符串s前后端所有cutset子串的字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="string">"eeeTRsaeAAAeweee"</span></span><br><span class="line"><span class="comment">// 去掉字符串两边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.Trim(c, <span class="string">"eee"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>TRsaeAAAew</p></blockquote><p><strong>（11）func TrimSpace(s string) string</strong></p><p>返回去掉字符串s前后端空白字符（unicode.IsSpace指定）的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d := <span class="string">"   eeeTRsaeAAAeweee   "</span></span><br><span class="line"><span class="comment">// 去掉字符串两边的空白符</span></span><br><span class="line">fmt.Println(strings.TrimSpace(d))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>eeeTRsaeAAAeweee</p></blockquote><p><strong>（12）func TrimLeft(s string, cutset string) string</strong></p><p>返回去掉字符串s前端所有cutset子串的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e := <span class="string">"aaayxseryewerrrr"</span></span><br><span class="line"><span class="comment">// 去掉字符串左边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimLeft(e, <span class="string">"a"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>yxseryewerrrr</p></blockquote><p><strong>（13）func TrimRight(s string, cutset string) string</strong></p><p>返回去掉字符串s后端所有cutset子串的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉字符串右边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimRight(e, <span class="string">"r"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>aaayxseryewe</p></blockquote><p><strong>（14）func TrimPrefix(s, prefix string) string</strong></p><p>返回去掉字符串s的前缀prefix子串的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉字符串开头的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimPrefix(e, <span class="string">"aaayx"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>seryewerrrr</p></blockquote><p><strong>（15）func TrimSuffix(s, suffix string) string</strong></p><p>返回去掉字符串s的后缀suffix子串的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉字符串结尾的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimSuffix(e, <span class="string">"werrrr"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>aaayxserye</p></blockquote><p><strong>（16）func Fields(s string) []string</strong></p><p>返回将字符串s按一个或多个空白（unicode.IsSpace）字符分割的多个字符串切片；空白字符串或空字符串返回空切片；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="string">"Hi, Tim, how are you!"</span></span><br><span class="line"><span class="comment">// 将字符串进行切割再返回</span></span><br><span class="line">fmt.Println(strings.Fields(f))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>[Hi, Tim, how are you!]</p></blockquote><p><strong>（17）func Split(s, sep string) []string</strong></p><p>返回将字符串s按一个sep子串分割的字符串切片；sep为空字符串时，将s分割为每一个unicode码值的字符串切片；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g := <span class="string">"just relax and take it easy"</span></span><br><span class="line"><span class="comment">// 将字符串以指定字符串进行切割再返回</span></span><br><span class="line">result := strings.Split(g, <span class="string">" "</span>)</span><br><span class="line">fmt.Printf(<span class="string">"result' type: %T\n"</span>, result)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(result))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>result’ type: []string   // 返回的是一个字符串数组<br>6   // 该数组有6个元素</p></blockquote><p><strong>（18）func Join(a []string, sep string) string</strong></p><p>返回将字符串切片a以子串sep连接的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拼接字符串</span></span><br><span class="line">h := <span class="string">"I"</span></span><br><span class="line">i := <span class="string">"love"</span></span><br><span class="line">j := <span class="string">"you"</span></span><br><span class="line">fmt.Println(strings.Join([]<span class="keyword">string</span>&#123;h, i, j&#125;, <span class="string">" "</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>I love you</p></blockquote><p>以上代码省略部分内容，完整代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="string">"threereyed"</span></span><br><span class="line"><span class="comment">// 判断字符串中是否以指定字符串开头</span></span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">"th"</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">"ht"</span>))</span><br><span class="line"><span class="comment">// 判断字符串中是否以指定字符串结尾</span></span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">"ed"</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">"sa"</span>))</span><br><span class="line"><span class="comment">// 判断字符串中是否包含某个字符串</span></span><br><span class="line">fmt.Println(strings.Contains(a, <span class="string">"ree"</span>))</span><br><span class="line"><span class="comment">// 返回字符串中有几个指定的字符串</span></span><br><span class="line">fmt.Println(strings.Count(a, <span class="string">"e"</span>))</span><br><span class="line"><span class="comment">// 返回字符串中指定字符串第一次出现的位置</span></span><br><span class="line">fmt.Println(strings.Index(a, <span class="string">"e"</span>))</span><br><span class="line"></span><br><span class="line">b := <span class="string">"ThreeREyeD"</span></span><br><span class="line"><span class="comment">// 返回转小写后的字符串</span></span><br><span class="line">fmt.Println(strings.ToLower(b))</span><br><span class="line"><span class="comment">// 返回转大写后的字符串</span></span><br><span class="line">fmt.Println(strings.ToUpper(b))</span><br><span class="line"><span class="comment">// 将输入的字符串以指定的重复次数拼接后返回</span></span><br><span class="line">fmt.Println(strings.Repeat(b, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// 替换字符串中的子字符串，当替换次数小于0的时候替换所有的子字符串</span></span><br><span class="line">fmt.Println(strings.Replace(b, <span class="string">"e"</span>, <span class="string">"T"</span>, <span class="number">1</span>))</span><br><span class="line">fmt.Println(strings.Replace(b, <span class="string">"e"</span>, <span class="string">"T"</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">c := <span class="string">"eeeTRsaeAAAeweee"</span></span><br><span class="line"><span class="comment">// 去掉字符串两边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.Trim(c, <span class="string">"eee"</span>))</span><br><span class="line"></span><br><span class="line">d := <span class="string">"   eeeTRsaeAAAeweee   "</span></span><br><span class="line"><span class="comment">// 去掉字符串两边的空白符</span></span><br><span class="line">fmt.Println(strings.TrimSpace(d))</span><br><span class="line"></span><br><span class="line">e := <span class="string">"aaayxseryewerrrr"</span></span><br><span class="line"><span class="comment">// 去掉字符串左边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimLeft(e, <span class="string">"a"</span>))</span><br><span class="line"><span class="comment">// 去掉字符串右边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimRight(e, <span class="string">"r"</span>))</span><br><span class="line"><span class="comment">// 去掉字符串开头的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimPrefix(e, <span class="string">"aaayx"</span>))</span><br><span class="line"><span class="comment">// 去掉字符串结尾的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimSuffix(e, <span class="string">"werrrr"</span>))</span><br><span class="line"></span><br><span class="line">f := <span class="string">"Hi, Tim, how are you!"</span></span><br><span class="line"><span class="comment">// 将字符串进行切割再返回</span></span><br><span class="line">fmt.Println(strings.Fields(f))</span><br><span class="line"></span><br><span class="line">g := <span class="string">"just relax and take it easy"</span></span><br><span class="line"><span class="comment">// 将字符串以指定字符串进行切割再返回</span></span><br><span class="line">result := strings.Split(g, <span class="string">" "</span>)</span><br><span class="line">fmt.Printf(<span class="string">"result' type: %T\n"</span>, result)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接字符串</span></span><br><span class="line">h := <span class="string">"I"</span></span><br><span class="line">i := <span class="string">"love"</span></span><br><span class="line">j := <span class="string">"you"</span></span><br><span class="line">fmt.Println(strings.Join([]<span class="keyword">string</span>&#123;h, i, j&#125;, <span class="string">" "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>true<br>false<br>true<br>false<br>true<br>4<br>3<br>threereyed<br>THREEREYED<br>ThreeREyeDThreeREyeDThreeREyeD<br>ThrTeREyeD<br>ThrTTREyTD<br>TRsaeAAAew<br>eeeTRsaeAAAeweee<br>yxseryewerrrr<br>aaayxseryewe<br>seryewerrrr<br>aaayxserye<br>[Hi, Tim, how are you!]<br>result’ type: []string<br>6<br>I love you</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量来源"><a href="#变量来源" class="headerlink" title="变量来源"></a>变量来源</h3><p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。</p><p>变量可以通过变量名访问。</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>一般常用的有，数值型、布尔型、字符串类型、派生类型</p><p>派生类型包括：</p><ul><li>(a) 指针类型（Pointer）</li><li>(b) 数组类型</li><li>(c) 结构化类型(struct)</li><li>(d) Channel 类型</li><li>(e) 函数类型</li><li>(f) 切片类型</li><li>(g) 接口类型（interface）</li><li>(h) Map 类型</li></ul><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="第一种方式：指定变量类型，如果没有初始化，则变量默认为零值"><a href="#第一种方式：指定变量类型，如果没有初始化，则变量默认为零值" class="headerlink" title="第一种方式：指定变量类型，如果没有初始化，则变量默认为零值"></a>第一种方式：指定变量类型，如果没有初始化，则变量默认为零值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span> <span class="comment">// 声明一个变量名为a的变量，其类型为int，值为1</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span> = <span class="string">"threereyed"</span> <span class="comment">// 声明一个变量名为b的变量，其类型为string，值为threereyed</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">fmt.Println(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不给变量设置值则默认为零值</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">int</span></span><br><span class="line">fmt.Println(d)</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">string</span></span><br><span class="line">fmt.Println(e)</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">bool</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出为：</p><blockquote><p>D:\Go\src\github.com\ThreeREyed\studygo\day02&gt;go run main.go<br>1<br>threereyed<br>true<br>0</p><p>false</p></blockquote><h4 id="第二种，根据值自行判定变量类型"><a href="#第二种，根据值自行判定变量类型" class="headerlink" title="第二种，根据值自行判定变量类型"></a>第二种，根据值自行判定变量类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据值来判断类型</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="string">"threereyed"</span></span><br><span class="line">fmt.Println(g, h)</span><br></pre></td></tr></table></figure><p>以上代码的输出为：</p><blockquote><p>20 threereyed</p></blockquote><h4 id="第三种，省略-var，-，-只在函数中体现（短变量声明）"><a href="#第三种，省略-var，-，-只在函数中体现（短变量声明）" class="headerlink" title="第三种，省略 var，:= ， 只在函数中体现（短变量声明）"></a>第三种，省略 var，:= ， 只在函数中体现（短变量声明）</h4><p><strong>注意 \</strong>:=** 左侧如果没有声明新的变量，就产生编译错误**</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据值来判断类型</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="string">"threereyed"</span></span><br><span class="line">fmt.Println(g, h)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略var 使用:= 的方式来声明，:= 左侧必须是有新的变量产生</span></span><br><span class="line">i := <span class="number">30</span></span><br><span class="line">g := <span class="number">40</span> <span class="comment">// 此时产生编译错误no new variables on left side of :=go</span></span><br><span class="line">g, j := <span class="number">40</span>, <span class="number">50</span> <span class="comment">// 因为左侧有新的变量声明，所以不会有编译错误</span></span><br></pre></td></tr></table></figure><h4 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">// 和 python 很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。</p><p>如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。</p><p>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误</p><p>但是全局变量是<strong>允许声明但不使用</strong>。</p><p>同一类型的多个变量可以声明在同一行</p><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</p><p><strong>驼峰命名</strong></p><p>大驼峰（eg: ThreeEyed），小驼峰(threeEyed)</p><p><strong>下划线连接</strong></p><p>eg: three_eyed</p><p>匿名变量 <code>-</code></p><p>空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。</p><p>_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。 </p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是一个简单值的标识符，在程序运行过程中，不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p><strong>关键字<code>const</code></strong></p><h3 id="常量声明方式"><a href="#常量声明方式" class="headerlink" title="常量声明方式"></a>常量声明方式</h3><p><strong>声明单个常量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure><p>你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p><ul><li>显式类型定义： <code>const b string = &quot;abc&quot;</code></li><li>隐式类型定义： <code>const b = &quot;abc&quot;</code></li></ul><p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过</p><p><strong>单行声明常量</strong></p><p>多个相同类型的声明可以简写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c_name1, c_name2 = value1, value2</span><br></pre></td></tr></table></figure><p><strong>批量声明常量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conset &#123;</span><br><span class="line">name1 <span class="keyword">string</span></span><br><span class="line">name2 <span class="keyword">bool</span></span><br><span class="line">name3 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">name1 = <span class="number">1</span></span><br><span class="line">name2</span><br><span class="line">name3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(name1, name2, name3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const 批量声明常量时，如果没有被赋值，那么上一行的值会赋给下一行没有赋值的常量，以上代码输出内容为</p><blockquote><p>1 1 1</p></blockquote><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><h4 id="常量计数器"><a href="#常量计数器" class="headerlink" title="常量计数器"></a>常量计数器</h4><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p><p>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="literal">iota</span></span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">iota</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(a, b, c, d, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出为：</p><blockquote><p>0 1 2 0 0</p></blockquote><p>批量声明中的iota 随着常量增加而增加，但是const 再出现时，iota 被重新设置为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">"ha"</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//"ha"   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出为：</p><blockquote><p>0  1 2 ha ha 100 100 7 8</p></blockquote><p>充分说明iota 是一个常量计数器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    i=<span class="number">1</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    j=<span class="number">3</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"i="</span>,i)</span><br><span class="line">    fmt.Println(<span class="string">"j="</span>,j)</span><br><span class="line">    fmt.Println(<span class="string">"k="</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">"l="</span>,l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例运行结果为：</p><blockquote><p>i= 1<br>j= 6<br>k= 12<br>l= 24</p></blockquote><p>iota 表示从 0 开始自动加 1，所以 <strong>i=1&lt;&lt;0</strong>, <strong>j=3&lt;&lt;1</strong>（<strong>&lt;&lt;</strong> 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 <strong>k=3&lt;&lt;2</strong>，<strong>l=3&lt;&lt;3</strong>。</p><p>简单表述:</p><ul><li><p>i=1</p></li><li><p>：左移 0 位,不变仍为 1;</p></li><li><p><strong>j=3</strong>：左移 1 位,变为二进制 110, 即 6;</p></li><li><p><strong>k=3</strong>：左移 2 位,变为二进制 1100, 即 12;</p></li><li><p><strong>l=3</strong>：左移 3 位,变为二进制 11000,即 24。</p></li></ul><h4 id="用来定义数量级"><a href="#用来定义数量级" class="headerlink" title="用来定义数量级"></a>用来定义数量级</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意：</p><p><code>&lt;&lt;n == *(2^n)</code></p><p>左移运算符 <strong>&lt;&lt;</strong> 是双目运算符。左移 n 位就是乘以 2 的 n 次方。 其功能把 <strong>&lt;&lt;</strong> 左边的运算数的各二进位全部左移若干位，由 <strong>&lt;&lt;</strong> 右边的数指定移动的位数，高位丢弃，低位补 0。</p><p>右移运算符 <strong>&gt;&gt;</strong> 是双目运算符。右移 n 位就是除以 2 的 n 次方。 其功能是把 <strong>&gt;&gt;</strong> 左边的运算数的各二进位全部右移若干位， <strong>&gt;&gt;</strong> 右边的数指定移动的位数。</p><div class="note warning">            <p>本节部分内容引自<a href="https://www.runoob.com/go/go-variables.html" target="_blank" rel="noopener">菜鸟教程</a> <a href="https://www.liwenzhou.com/posts/Go/01_var_and_const/" target="_blank" rel="noopener">李文周的博客</a></p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day01</title>
    <link href="http://threereyed.top/2020/05/20/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0day01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day01/"/>
    <id>http://threereyed.top/2020/05/20/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0day01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day01/</id>
    <published>2020-05-20T14:17:49.000Z</published>
    <updated>2020-05-25T15:48:35.423Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>每天记录一点点之go语言基础学习第一天</strong></p><h2 id="Golang的环境搭建"><a href="#Golang的环境搭建" class="headerlink" title="Golang的环境搭建"></a>Golang的环境搭建</h2><ol><li>go下载</li><li>配置环境变量</li></ol><p>可参考大佬博客 <a href="https://www.liwenzhou.com/posts/Go/install_go_dev/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/install_go_dev/</a></p><h2 id="ide-下载"><a href="#ide-下载" class="headerlink" title="ide 下载"></a>ide 下载</h2><p>go语言支持utf-8编码，只要能支持utf-8编码的都可以写go程序，</p><p>一般使用Goland、Vs code、Sublime，Goland 大型项目使用，但是容易卡顿，JB的软件大都这样，Vs code需要自己下载插件来用</p><h2 id="Go-工程目录"><a href="#Go-工程目录" class="headerlink" title="Go 工程目录"></a>Go 工程目录</h2><p><img src="https://i.loli.net/2020/05/23/fXzDQRLnVgy7AO6.png" alt=""></p><h2 id="第一个go程序"><a href="#第一个go程序" class="headerlink" title="第一个go程序"></a>第一个go程序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p> go的所有文件都需要指定包，包有两种类型，一种是 <strong>main</strong> 包，使用 <code>package main</code> 在代码的最前面声明。另外一种就是 <strong>非main</strong> 包，使用 <code>package</code>  + <code>包名</code> 。main 包的可以有唯一的一个 main 函数，这个函数也是程序的入口。也只有 main 包可以编译成可执行的文件。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><code>import &quot;fmt&quot;</code>：最常用的一种形式</p><p><code>import &quot;./test&quot;</code>：导入同一目录下test包中的内容</p><p><code>import f &quot;fmt&quot;</code>：导入fmt，并给他启别名ｆ</p><p><code>import . &quot;fmt&quot;</code>：将fmt启用别名”.”，这样就可以直接使用其内容，而不用再添加ｆｍｔ，如fmt.Println可以直接写成Println</p><p><code>import _ &quot;fmt&quot;</code> ：表示不使用该包，而是只是使用该包的init函数，并不显示的使用该包的其他内容。注意：这种形式的import，当import时就执行了fmt包中的init函数，而不能够使用该包的其他函数。</p><p><code>import (&quot;fmt&quot;)</code> 也可以这么写</p><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>程序的入口</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li><p><code>go build</code> ：程序写完之后使用go build 进行编译，编译完成后生成可执行文件（windows下为后缀为.exe 的文件）</p></li><li><p><code>go install</code>:  go install 执行了两个步骤，先执行go build 再将生成的可执行文件拷贝到go path 的bin目录下</p></li><li><p><code>go build -o 文件名</code> :  -o 可以重新指定文件名 </p></li><li><p><code>go run</code>:  执行脚本文件</p></li><li><p>交叉编译：</p><p>在windows下可以编译在linux平台执行的文件</p><p>只需要指定目标操作系统的平台和处理器架构即可：</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">&gt;SET GOOS=linux  // 目标平台是linux</span><br><span class="line">&gt;SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure><p><em>使用了cgo的代码是不支持跨平台编译的</em></p><p>然后再执行<code>go build</code>命令，得到的就是能够在Linux平台运行的可执行文件了。</p></blockquote></li></ul><h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>编译之后点击可执行文件既可以运行程序</p>]]></content>
    
    <summary type="html">
    
      Go语言基础学习day01
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
</feed>
