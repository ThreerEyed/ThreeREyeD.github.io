<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>threereyed</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://threereyed.top/"/>
  <updated>2020-06-07T04:17:21.100Z</updated>
  <id>http://threereyed.top/</id>
  
  <author>
    <name>threereyed</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>goroutine</title>
    <link href="http://threereyed.top/go-basics/Go-basics-day09/goroutine/"/>
    <id>http://threereyed.top/go-basics/Go-basics-day09/goroutine/</id>
    <published>2020-06-05T02:35:02.000Z</published>
    <updated>2020-06-07T04:17:21.100Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning">            <p>这是一个创建于 2020-06-05 10:35:02 的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><hr><h2 id="并发、并行、同步、异步"><a href="#并发、并行、同步、异步" class="headerlink" title="并发、并行、同步、异步"></a>并发、并行、同步、异步</h2><p>几乎只要一提到高并发，这几个词几乎都会一起出现，面试也会经常问关于它们的区别，虽然自己都能描述一些，但是不够详尽，这里花时间对这几个概念进行充分理解。</p><p><strong>同步</strong>：任务依次执行，下一个任务必须等待上一个任务出了结果之后再继续执行，容易阻塞。</p><p><strong>异步</strong>：任务的执行没有顺序，在较短时间内，启动运行多个任务，不关系任务结果，任务启动之后，不用等待该任务的结果返回，可以继续执行另外一个任务，然后通过其他方式得知任务执行的结果</p><p><strong>并发</strong>：在某个时间段里，有多个任务请求，然后我们交替处理这些任务，并发往往就是对资源的一个合理调度。古老的计算器处理器是单核的，当有多个任务请求时，处理器会处理这些任务，但是不是同时处理的，每个任务有自己的优先处理管理，当该任务需要优先处理，那么处理器就腾出资源来处理这个任务，然后等到下一个任务优先处理的时候就把上一个任务挂起，处理下一个优先的任务，如此往复。</p><p><strong>并行</strong>：在一个时间点，有多个任务在运行，就说这些任务在并行执行，往往是说有有多个资源在同时执行相同或者不相同的任务，例如cpu的多核，8个核心处理器，在某一个时间点， 都在执行不同的任务。</p><p>并发在微观上（具体的某个时刻）不是同步执行的，只是cpu根据任务的优先情况交替处理这些任务，但是在宏观上（某个时间段）看起来是同时执行的。</p><p>并行无论在微观还是宏观都是同时执行的。</p><p>总结下同步、异步、并发、并行的特点：</p><table><thead><tr><th></th><th>特点</th></tr></thead><tbody><tr><td>同步</td><td>顺序执行，等待执行结果</td></tr><tr><td>异步</td><td>没有固定的执行顺序，不用一直等待某个任务的执行结果，通过其他方式得到结果</td></tr><tr><td>并发</td><td>并发性是对有限物理资源强制行使多用户共享以提高效率（单核交替处理任务，假并行）</td></tr><tr><td>并行</td><td>同时执行不相干的任务，真正意义的同时执行</td></tr></tbody></table><hr><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Go语言的并发通过<code>goroutine</code>实现。<code>goroutine</code>类似于线程，属于用户态的线程，我们可以根据需要创建成千上万个<code>goroutine</code>并发工作。<code>goroutine</code>是由Go语言的运行时（runtime）调度完成，而线程是由操作系统调度完成。</p><p>Go语言还提供<code>channel</code>在多个<code>goroutine</code>间进行通信。<code>goroutine</code>和<code>channel</code>是 Go 语言秉承的 CSP（Communicating Sequential Process）并发模式的重要实现基础。</p><h3 id="内核态线程和用户态线程"><a href="#内核态线程和用户态线程" class="headerlink" title="内核态线程和用户态线程"></a>内核态线程和用户态线程</h3><p>所谓用户态线程就是把内核态的线程在用户态实现了一遍而已，目的是更轻量化（更少的内存占用、更少的隔离、更快的调度）和更高的可控性（可以自己控制调度器）。用户态所有东西内核态都「看得见」，只是对于内核而言「用户态线程」只是一堆内存数据而已。</p><h3 id="go语言的运行时"><a href="#go语言的运行时" class="headerlink" title="go语言的运行时"></a>go语言的运行时</h3><p>尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收（第 10.8 节）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。</p><p>runtime 主要由 C 语言编写（Go 1.5 开始自举），并且是每个 Go 包的最顶级包。你可以在目录 <a href="https://github.com/golang/go/tree/master/src/runtime" target="_blank" rel="noopener"><code>$GOROOT/src/runtime</code></a> 中找到相关内容。</p><p><strong>垃圾回收器</strong> Go 拥有简单却高效的标记-清除回收器。它的主要思想来源于 IBM 的可复用垃圾回收器，旨在打造一个高效、低延迟的并发回收器。目前 gccgo 还没有回收器，同时适用 gc 和 gccgo 的新回收器正在研发中。使用一门具有垃圾回收功能的编程语言不代表你可以避免内存分配所带来的问题，分配和回收内容都是消耗 CPU 资源的一种行为。</p><p>Go 的可执行文件都比相对应的源代码文件要大很多，这恰恰说明了 Go 的 runtime 嵌入到了每一个可执行文件当中。当然，在部署到数量巨大的集群时，较大的文件体积也是比较头疼的问题。但总的来说，Go 的部署工作还是要比 Java 和 Python 轻松得多。因为 Go 不需要依赖任何其它文件，它只需要一个单独的静态文件，这样你也不会像使用其它语言一样在各种不同版本的依赖文件之间混淆。</p><p>关于go语言的运行时 转自于 <a href="https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/02.7.md" target="_blank" rel="noopener">https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/02.7.md</a></p><hr><h2 id="关于goroutine"><a href="#关于goroutine" class="headerlink" title="关于goroutine"></a>关于goroutine</h2><p>Go语言中的<code>goroutine</code>就是这样一种机制，<code>goroutine</code>的概念类似于线程，但 <code>goroutine</code>是由Go的运行时（runtime）调度和管理的。Go程序会智能地将 goroutine 中的任务合理地分配给每个CPU。Go语言之所以被称为现代化的编程语言，就是因为它在语言层面已经内置了调度和上下文切换的机制。</p><p>在Go语言编程中你不需要去自己写进程、线程、协程，你的技能包里只有一个技能–<code>goroutine</code>，当你需要让某个任务并发执行的时候，你只需要把这个任务包装成一个函数，开启一个<code>goroutine</code>去执行这个函数就可以了，就是这么简单粗暴。</p><h3 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h3><p>在go程序中，一般有一个主goroutine，就是我们的程序入口main 函数所在的，其他的goroutine 是由主goroutine 分化出来的。</p><p>以下实例为启动一个goroutine </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printfn(<span class="string">"你好啊。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">go</span> hello()</span><br><span class="line">    fmt.Printfn(<span class="string">"main goroutine down"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序返回的结果:</p><blockquote><p>main goroutine down</p></blockquote><p>go语言并发使用goroutine 来完成非常简单，我们只需要在函数前加一个  <code>go</code> 关键字，就可以启动一个goroutine ，但是这里我们发现一个问题，我们只有一行打印，这个打印是main函数中的打印，hello 函数中的打印则没有，这是因为main函数也是一个goroutine 而且是主要的g，当main函数执行完返回后，主gouroutine 也就结束了</p><p>创建goroutine 也是需要时间的</p><p><code>main</code>函数所在的<code>goroutine</code>就像是权利的游戏中的夜王，其他的<code>goroutine</code>都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>这里要想实现我们的并发操作，那么则需要让主g 等待hello 函数这一个g，最简单的实现方式就是使用<code>time.sleep()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"你好啊。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> hello()</span><br><span class="line">time.Sleep(<span class="number">1</span>)  <span class="comment">// 等待hello 函数所在的goroutine 执行完</span></span><br><span class="line">fmt.Println(<span class="string">"main goroutine down"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="goroutine-结束时间"><a href="#goroutine-结束时间" class="headerlink" title="goroutine 结束时间"></a>goroutine 结束时间</h3><p>一个goroutine 对应一个函数，当函数返回的时候，这个函数所在的goroutine 也就结束了</p><div class="note info">            <p>在很多时候，使用sleep 都不是一个很好的操作，等待时间过于僵化，不够灵活和精明</p>          </div><h3 id="使用优雅的方式等待goroutine-结束（sync-WaitGroup）"><a href="#使用优雅的方式等待goroutine-结束（sync-WaitGroup）" class="headerlink" title="使用优雅的方式等待goroutine 结束（sync.WaitGroup）"></a>使用优雅的方式等待goroutine 结束（sync.WaitGroup）</h3><p>用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">// 使用sync 下的包waitgroup 并声明一个变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()   <span class="comment">// 在函数执行将要返回之时，执行。类似于计数器减一的操作</span></span><br><span class="line">fmt.Println(<span class="string">"你好啊。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">wg.Add(<span class="number">1</span>)  <span class="comment">// 启动一个goroutine 计数器加一</span></span><br><span class="line"><span class="keyword">go</span> hello()</span><br><span class="line">wg.Wait()  <span class="comment">// 等待goroutine 完成</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"main goroutine down"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><p>在Go语言中实现并发就是这样简单，我们还可以启动多个<code>goroutine</code>。让我们再来一个例子： （这里使用了<code>sync.WaitGroup</code>来实现goroutine的同步）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">fmt.Println(<span class="string">"Hello Goroutine!"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line"><span class="keyword">go</span> hello(i)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为10个<code>goroutine</code>是并发执行的，而<code>goroutine</code>的调度是随机的。</p><h3 id="goroutine-与线程"><a href="#goroutine-与线程" class="headerlink" title="goroutine 与线程"></a>goroutine 与线程</h3><h4 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h4><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个<code>goroutine</code>的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<code>goroutine</code>的栈不是固定的，他可以按需增大和缩小，<code>goroutine</code>的栈大小限制可以达到1GB，虽然极少会用到这么大。所以在Go语言中一次创建十万左右的<code>goroutine</code>也是可以的。</p><h3 id="goroutine-的调度"><a href="#goroutine-的调度" class="headerlink" title="goroutine 的调度"></a>goroutine 的调度</h3><p><strong>gotoutine  是通过GPM（Goroutine、Processor、Machine） 这一套调度系统来调度的</strong></p><h4 id="GPM："><a href="#GPM：" class="headerlink" title="GPM："></a>GPM：</h4><p>G、P、M 是 Go 调度器的三个核心组件，各司其职。在它们精密地配合下，Go 调度器得以高效运转，这也是 Go 天然支持高并发的内在动力。</p><p>先看 G，取 goroutine 的首字母，主要保存 goroutine 的一些状态信息以及 CPU 的一些寄存器的值，例如 IP 寄存器，以便在轮到本 goroutine 执行时，CPU 知道要从哪一条指令处开始执行。</p><p>当 goroutine 被调离 CPU 时，调度器负责把 CPU 寄存器的值保存在 g 对象的成员变量之中。</p><p>当 goroutine 被调度起来运行时，调度器又负责把 g 对象的成员变量所保存的寄存器值恢复到 CPU 的寄存器。</p><p>上面这段描述来自公众号“go语言核心编程技术”的调度器系列文章。</p><p><code>GPM</code>是Go语言运行时（runtime）层面的实现，是go语言自己实现的一套调度系统。区别于操作系统调度OS线程。</p><ul><li><code>G</code>很好理解，就是个goroutine的，里面除了存放本goroutine信息外 还有与所在P的绑定等信息。</li><li><code>P</code>管理着一组goroutine队列，P里面会存储当前goroutine运行的上下文环境（函数指针，堆栈地址及地址边界），P会对自己管理的goroutine队列做一些调度（比如把占用CPU时间较长的goroutine暂停、运行后续的goroutine等等）当自己的队列消费完了就去全局队列里取，如果全局队列里也消费完了会去其他P的队列里抢任务。</li><li><code>M（machine）</code>是Go运行时（runtime）对操作系统内核线程的虚拟， M与内核线程一般是一一映射的关系， 一个groutine最终是要放到M上执行的；</li></ul><p>P与M一般也是一一对应的。他们关系是： P管理着一组G挂载在M上运行。当一个G长久阻塞在一个M上时，runtime会新建一个M，阻塞G所在的P会把其他的G 挂载在新建的M上。当旧的G阻塞完成或者认为其已经死掉时 回收旧的M。</p><p>P的个数是通过<code>runtime.GOMAXPROCS</code>设定（最大256），Go1.5版本之后默认为物理线程数。 在并发量大的时候会增加一些P和M，但不会太多，切换太频繁的话得不偿失。</p><p>单从线程调度讲，Go语言相比起其他语言的优势在于OS线程是由OS内核来调度的，<code>goroutine</code>则是由Go运行时（runtime）自己的调度器调度的，这个调度器使用一个称为m:n调度的技术（复用/调度m个goroutine到n个OS线程）。 其一大特点是goroutine的调度是在用户态下完成的， 不涉及内核态与用户态之间的频繁切换，包括内存的分配与释放，都是在用户态维护着一块大的内存池， 不直接调用系统的malloc函数（除非内存池需要改变），成本比调度OS线程低很多。 另一方面充分利用了多核的硬件资源，近似的把若干goroutine均分在物理线程上， 再加上本身goroutine的超轻量，以上种种保证了go调度方面的性能。</p><p><a href="https://www.cnblogs.com/sunsky303/p/9705727.html" target="_blank" rel="noopener">点我了解更多</a></p><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>Go运行时的调度器使用<code>GOMAXPROCS</code>参数来确定需要使用多少个OS线程来同时执行Go代码。默认值是机器上的CPU核心数。例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上（GOMAXPROCS是m:n调度中的n）。</p><p>Go语言中可以通过<code>runtime.GOMAXPROCS()</code>函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><p>我们可以通过将任务分配到不同的CPU逻辑核心上实现并行的效果，这里举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个任务只有一个逻辑核心，此时是做完一个任务再做另一个任务。 将逻辑核心数设为2，此时两个任务并行执行，代码如下。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"A:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Println(<span class="string">"B:"</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">go</span> a()</span><br><span class="line"><span class="keyword">go</span> b()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go语言中的操作系统线程和goroutine的关系：</p><ol><li>一个操作系统线程对应用户态多个goroutine。</li><li>go程序可以同时使用多个操作系统线程。</li><li>goroutine和OS线程是多对多的关系，即m:n。</li></ol><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的<code>goroutine</code>中容易发生竞态问题。为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是<code>CSP（Communicating Sequential Processes）</code>，提倡<strong>通过通信共享内存</strong>而不是<strong>通过共享内存而实现通信</strong>。</p><p>如果说<code>goroutine</code>是Go程序并发的执行体，<code>channel</code>就是它们之间的连接。<code>channel</code>是可以让一个<code>goroutine</code>发送特定值到另一个<code>goroutine</code>的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。</p><p>channel 是一种类型，是一种引用类型，我们可以使用make 来创建一个channel 类型</p><p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 <code>&lt;-</code> 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明格式如下</span></span><br><span class="line"><span class="keyword">var</span> 变量 <span class="keyword">chan</span> 元素类型</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个channel 类型(用来传递int类型)</span></span><br><span class="line"><span class="keyword">var</span> channel1 <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 声明一个channel 类型(用来传递float类型)</span></span><br><span class="line"><span class="keyword">var</span> channel2 <span class="keyword">chan</span> float</span><br><span class="line"><span class="comment">// 声明一个channel 类型(用来传递int切片类型)</span></span><br><span class="line"><span class="keyword">var</span> channel3 <span class="keyword">chan</span> []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>使用make 函数对声明的通道进行初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> 元素类型, [缓冲大小])</span><br></pre></td></tr></table></figure><h3 id="channel操作"><a href="#channel操作" class="headerlink" title="channel操作"></a>channel操作</h3><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用<code>&lt;-</code>符号。</p><p>现在我们先使用以下语句定义一个通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><p>将一个值发送到通道中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="number">10</span> <span class="comment">// 把10发送到ch中</span></span><br></pre></td></tr></table></figure><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><p>从一个通道中接收值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := &lt;- ch <span class="comment">// 从ch中接收值并赋值给变量x</span></span><br><span class="line">&lt;-ch       <span class="comment">// 从ch中接收值，忽略结果</span></span><br></pre></td></tr></table></figure><h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>我们通过调用内置的<code>close</code>函数来关闭通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>关于关闭通道需要注意的事情是，只有在通知接收方goroutine所有的数据都发送完毕的时候才需要关闭通道。通道是可以被垃圾回收机制回收的，它和关闭文件是不一样的，在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ol><li>对一个关闭的通道再发送值就会导致panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致panic。</li></ol><h3 id="无缓冲的通道"><a href="#无缓冲的通道" class="headerlink" title="无缓冲的通道"></a>无缓冲的通道</h3><p>无缓冲的通道又称为阻塞的通道。我们来看一下下面的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码能够通过编译，但是执行的时候会出现以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">        .../src/github.com/Q1mi/studygo/day06/channel02/main.go:8 +0x54</span><br></pre></td></tr></table></figure><p>为什么会出现<code>deadlock</code>错误呢？</p><p>因为我们使用<code>ch := make(chan int)</code>创建的是无缓冲的通道，无缓冲的通道只有在有人接收值的时候才能发送值。就像你住的小区没有快递柜和代收点，快递员给你打电话必须要把这个物品送到你的手中，简单来说就是无缓冲的通道必须有接收才能发送。</p><p>上面的代码会阻塞在<code>ch &lt;- 10</code>这一行代码形成死锁，那如何解决这个问题呢？</p><p>一种方法是启用一个<code>goroutine</code>去接收值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">ret := &lt;-c</span><br><span class="line">fmt.Println(<span class="string">"接收成功"</span>, ret)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> recv(ch) <span class="comment">// 启用goroutine从通道接收值</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无缓冲通道上的发送操作会阻塞，直到另一个<code>goroutine</code>在该通道上执行接收操作，这时值才能发送成功，两个<code>goroutine</code>将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个<code>goroutine</code>在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的<code>goroutine</code>同步化。因此，无缓冲通道也被称为<code>同步通道</code>。</p><h3 id="有缓冲的通道"><a href="#有缓冲的通道" class="headerlink" title="有缓冲的通道"></a>有缓冲的通道</h3><p>解决上面问题的方法还有一种就是使用有缓冲区的通道。我们可以在使用make函数初始化通道的时候为其指定通道的容量，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>) <span class="comment">// 创建一个容量为1的有缓冲区通道</span></span><br><span class="line">ch &lt;- <span class="number">10</span></span><br><span class="line">fmt.Println(<span class="string">"发送成功"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要通道的容量大于零，那么该通道就是有缓冲的通道，通道的容量表示通道中能存放元素的数量。就像你小区的快递柜只有那么个多格子，格子满了就装不下了，就阻塞了，等到别人取走一个快递员就能往里面放一个。</p><p>我们可以使用内置的<code>len</code>函数获取通道内元素的数量，使用<code>cap</code>函数获取通道的容量，虽然我们很少会这么做。</p><h3 id="单向通道"><a href="#单向通道" class="headerlink" title="单向通道"></a>单向通道</h3><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><p>Go语言中提供了<strong>单向通道</strong>来处理这种情况。例如，我们把上面的例子改造如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">out &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">out &lt;- i * i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> in &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> counter(ch1)</span><br><span class="line"><span class="keyword">go</span> squarer(ch2, ch1)</span><br><span class="line">printer(ch2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li><code>chan&lt;- int</code>是一个只写单向通道（只能对其写入int类型值），可以对其执行发送操作但是不能执行接收操作；</li><li><code>&lt;-chan int</code>是一个只读单向通道（只能从其读取int类型值），可以对其执行接收操作但是不能执行发送操作。</li></ul><p>在函数传参及任何赋值操作中可以将双向通道转换为单向通道，但反过来是不可以的。</p><h3 id="通道总结"><a href="#通道总结" class="headerlink" title="通道总结"></a>通道总结</h3><p><code>channel</code>常见的异常总结，如下图：<img src="https://i.loli.net/2020/06/07/MiFPOsA5QC3N9yh.png" alt="channel异常总结"></p><p>关闭已经关闭的<code>channel</code>也会引发<code>panic</code>。</p>]]></content>
    
    <summary type="html">
    
      关于go 语言并发的学习和理解
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/go-basics/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
      <category term="goroutine" scheme="http://threereyed.top/tags/goroutine/"/>
    
      <category term="channel" scheme="http://threereyed.top/tags/channel/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day08（文件操作）</title>
    <link href="http://threereyed.top/go-basics/Go-basics-day08/file-operations/"/>
    <id>http://threereyed.top/go-basics/Go-basics-day08/file-operations/</id>
    <published>2020-06-04T04:44:45.000Z</published>
    <updated>2020-06-04T04:54:13.548Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><hr><div class="note warning">            <p>这是一个创建于2020-06-04 12:44:45 的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><div class="note warning">            <p>该文章转载于 <a href="https://www.liwenzhou.com/posts/Go/go_file/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/go_file/</a></p>          </div><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>go语言的文件操作使用到的主要是<code>os</code> 这个包进行文件操作，python中也是使用的这个包</p><p>本文主要介绍了Go语言中文件读写的相关操作。</p><p>文件是什么？</p><p>计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件。</p><h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><p><code>os.Open()</code>函数能够打开一个文件，返回一个<code>*File</code>和一个<code>err</code>。对得到的文件实例调用<code>close()</code>方法能够关闭文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。</p><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>file.Read()</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>Read方法定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回<code>0</code>和<code>io.EOF</code>。 举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 使用Read方法读取数据</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"读取了%d字节数据\n"</span>, n)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(tmp[:n]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环读取"><a href="#循环读取" class="headerlink" title="循环读取"></a>循环读取</h4><p>使用for循环读取文件中的所有数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 只读方式打开当前目录下的main.go文件</span></span><br><span class="line">file, err := os.Open(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed!, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 循环读取文件</span></span><br><span class="line"><span class="keyword">var</span> content []<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">128</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := file.Read(tmp)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">content = <span class="built_in">append</span>(content, tmp[:n]...)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bufio读取文件"><a href="#bufio读取文件" class="headerlink" title="bufio读取文件"></a>bufio读取文件</h3><p>bufio是在file的基础上封装了一层API，支持更多的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// bufio按行读取示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.Open(<span class="string">"./xx.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">line, err := reader.ReadString(<span class="string">'\n'</span>) <span class="comment">//注意是字符</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(line) != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(line)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"文件读完了"</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(line)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ioutil读取整个文件"><a href="#ioutil读取整个文件" class="headerlink" title="ioutil读取整个文件"></a>ioutil读取整个文件</h3><p><code>io/ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ioutil.ReadFile读取整个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">content, err := ioutil.ReadFile(<span class="string">"./main.go"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"read file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件写入操作"><a href="#文件写入操作" class="headerlink" title="文件写入操作"></a>文件写入操作</h3><p><code>os.OpenFile()</code>函数能够以指定模式打开文件，从而实现文件写入相关功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm FileMode)</span> <span class="params">(*File, error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><p><code>name</code>：要打开的文件名 <code>flag</code>：打开文件的模式。 模式有以下几种：</p><table><thead><tr><th align="center">模式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>os.O_WRONLY</code></td><td align="center">只写</td></tr><tr><td align="center"><code>os.O_CREATE</code></td><td align="center">创建文件</td></tr><tr><td align="center"><code>os.O_RDONLY</code></td><td align="center">只读</td></tr><tr><td align="center"><code>os.O_RDWR</code></td><td align="center">读写</td></tr><tr><td align="center"><code>os.O_TRUNC</code></td><td align="center">清空</td></tr><tr><td align="center"><code>os.O_APPEND</code></td><td align="center">追加</td></tr></tbody></table><p><code>perm</code>：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</p><h4 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">"xx.txt"</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">str := <span class="string">"hello 沙河"</span></span><br><span class="line">file.Write([]<span class="keyword">byte</span>(str))       <span class="comment">//写入字节切片数据</span></span><br><span class="line">file.WriteString(<span class="string">"hello 小王子"</span>) <span class="comment">//直接写入字符串数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bufio-NewWriter"><a href="#bufio-NewWriter" class="headerlink" title="bufio.NewWriter"></a>bufio.NewWriter</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, err := os.OpenFile(<span class="string">"xx.txt"</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"open file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">writer.WriteString(<span class="string">"hello沙河\n"</span>) <span class="comment">//将数据先写入缓存</span></span><br><span class="line">&#125;</span><br><span class="line">writer.Flush() <span class="comment">//将缓存中的内容写入文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">"hello 沙河"</span></span><br><span class="line">err := ioutil.WriteFile(<span class="string">"./xx.txt"</span>, []<span class="keyword">byte</span>(str), <span class="number">0666</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"write file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="copyFile"><a href="#copyFile" class="headerlink" title="copyFile"></a>copyFile</h3><p>借助<code>io.Copy()</code>实现一个拷贝文件函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CopyFile 拷贝文件函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CopyFile</span><span class="params">(dstName, srcName <span class="keyword">string</span>)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 以读方式打开源文件</span></span><br><span class="line">src, err := os.Open(srcName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"open %s failed, err:%v.\n"</span>, srcName, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> src.Close()</span><br><span class="line"><span class="comment">// 以写|创建的方式打开目标文件</span></span><br><span class="line">dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, <span class="number">0644</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"open %s failed, err:%v.\n"</span>, dstName, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> dst.Close()</span><br><span class="line"><span class="keyword">return</span> io.Copy(dst, src) <span class="comment">//调用io.Copy()拷贝内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, err := CopyFile(<span class="string">"dst.txt"</span>, <span class="string">"src.txt"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"copy file failed, err:"</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"copy done!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个cat命令"><a href="#实现一个cat命令" class="headerlink" title="实现一个cat命令"></a>实现一个cat命令</h3><p>使用文件操作相关知识，模拟实现linux平台<code>cat</code>命令的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"bufio"</span></span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// cat命令实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(r *bufio.Reader)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">buf, err := r.ReadBytes(<span class="string">'\n'</span>) <span class="comment">//注意是字符</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">"%s"</span>, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Parse() <span class="comment">// 解析命令行参数</span></span><br><span class="line"><span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有参数默认从标准输入读取内容</span></span><br><span class="line">cat(bufio.NewReader(os.Stdin))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依次读取每个指定文件的内容并打印到终端</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">f, err := os.Open(flag.Arg(i))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stdout, <span class="string">"reading from %s failed, err:%v\n"</span>, flag.Arg(i), err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">cat(bufio.NewReader(f))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/go-basics/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day07 (接口)</title>
    <link href="http://threereyed.top/go-basics/Go-basics-day07/go-basics-day07/"/>
    <id>http://threereyed.top/go-basics/Go-basics-day07/go-basics-day07/</id>
    <published>2020-06-03T02:16:19.000Z</published>
    <updated>2020-06-04T02:34:27.888Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning">            <p>这是一个创建于 2020-05-29 14:14:59的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><br/><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的定义"><a href="#接口的定义" class="headerlink" title="接口的定义"></a>接口的定义</h3><p>接口是一种数据类型，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fox <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义方法，人，狗，狐狸都能够叫，都有一个speak 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"你好啊"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"汪汪汪~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fox)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"嘤嘤嘤~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个方法，传入一个参数就能实现speak 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jiao</span><span class="params">(a person)</span></span> &#123;</span><br><span class="line">a.speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line"><span class="keyword">var</span> d1 dog</span><br><span class="line"><span class="keyword">var</span> f1 fox</span><br><span class="line">jiao(p1)</span><br><span class="line">jiao(d1)</span><br><span class="line">jiao(f1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码发现一个问题，我们只能使用  <code>jiao(p1)</code>  ,因为jiao 这个方法的传入参数的类型只有  person 结构体，所以其他结构体想使用类似方法，只能重新定义其他的方法来实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line"><span class="keyword">var</span> d1 dog</span><br><span class="line"><span class="keyword">var</span> f1 fox</span><br><span class="line">jiao(p1)</span><br><span class="line">d1.speak()</span><br><span class="line">f1.speak()</span><br><span class="line"></span><br><span class="line"><span class="comment">// jiao(d1)</span></span><br><span class="line"><span class="comment">// jiao(f1)</span></span><br></pre></td></tr></table></figure><p>要使以上结构体都能实现<code>jiao()</code>  的方法 ，需要引入新的东西——接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引出接口的实例，定义接口</span></span><br><span class="line"><span class="keyword">type</span> speaker <span class="keyword">interface</span> &#123;</span><br><span class="line">speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fox <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"你好啊"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"汪汪汪~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f fox)</span> <span class="title">speak</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"嘤嘤嘤~"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jiao</span><span class="params">(a speaker)</span></span> &#123;</span><br><span class="line">a.speak()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> p1 person</span><br><span class="line"><span class="keyword">var</span> d1 dog</span><br><span class="line"><span class="keyword">var</span> f1 fox</span><br><span class="line">jiao(p1)</span><br><span class="line"></span><br><span class="line">jiao(d1)</span><br><span class="line">jiao(f1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>只要实现了我们定义的接口中 的speak()  这个方法的其他类型，我们就说实现了接口（就是这个speaker类型），就都可以使用jiao 这个方法</p><h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h3><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。换句话说，接口就是一个<strong>需要实现的方法列表</strong>。</p><h3 id="实现了接口的作用"><a href="#实现了接口的作用" class="headerlink" title="实现了接口的作用"></a>实现了接口的作用</h3><p>接口类型变量能够存储所有实现了该接口的实例。只要实现了接口，那么这个类型的实例就可以保存在接口中，并通过接口变量来调用类型的相关方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Sayer <span class="comment">// 声明一个Sayer类型的变量x</span></span><br><span class="line">a := cat&#123;&#125;  <span class="comment">// 实例化一个cat</span></span><br><span class="line">b := dog&#123;&#125;  <span class="comment">// 实例化一个dog</span></span><br><span class="line">x = a       <span class="comment">// 可以把cat实例直接赋值给x</span></span><br><span class="line">x.say()     <span class="comment">// 喵喵喵</span></span><br><span class="line">x = b       <span class="comment">// 可以把dog实例直接赋值给x</span></span><br><span class="line">x.say()     <span class="comment">// 汪汪汪</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tips：</strong> 观察下面的代码，体味此处<code>_</code>的妙用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘自gin框架routergroup.go</span></span><br><span class="line"><span class="keyword">type</span> IRouter <span class="keyword">interface</span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RouterGroup <span class="keyword">struct</span> &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ IRouter = &amp;RouterGroup&#123;&#125;  <span class="comment">// 确保RouterGroup实现了接口IRouter</span></span><br></pre></td></tr></table></figure><h3 id="值接收者和指针接收者实现接口的区别"><a href="#值接收者和指针接收者实现接口的区别" class="headerlink" title="值接收者和指针接收者实现接口的区别"></a>值接收者和指针接收者实现接口的区别</h3><p>使用值接收者实现接口和使用指针接收者实现接口有什么区别呢？接下来我们通过一个例子看一下其中的区别。</p><p>我们有一个<code>Mover</code>接口和一个<code>dog</code>结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> dog <span class="keyword">struct</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="值接收者实现接口"><a href="#值接收者实现接口" class="headerlink" title="值接收者实现接口"></a>值接收者实现接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"狗会动"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现接口的是<code>dog</code>类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"><span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">x = wangcai         <span class="comment">// x可以接收dog类型</span></span><br><span class="line"><span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">x.move()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以发现，使用值接收者实现接口之后，不管是dog结构体还是结构体指针<em>dog类型的变量都可以赋值给该接口变量。因为Go语言中有对指针类型变量求值的语法糖，dog指针<code>fugui</code>内部会自动求值`</em>fugui`。</p><h4 id="指针接收者实现接口"><a href="#指针接收者实现接口" class="headerlink" title="指针接收者实现接口"></a>指针接收者实现接口</h4><p>同样的代码我们再来测试一下使用指针接收者有什么区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *dog)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"狗会动"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x Mover</span><br><span class="line"><span class="keyword">var</span> wangcai = dog&#123;&#125; <span class="comment">// 旺财是dog类型</span></span><br><span class="line">x = wangcai         <span class="comment">// x不可以接收dog类型</span></span><br><span class="line"><span class="keyword">var</span> fugui = &amp;dog&#123;&#125;  <span class="comment">// 富贵是*dog类型</span></span><br><span class="line">x = fugui           <span class="comment">// x可以接收*dog类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时实现<code>Mover</code>接口的是<code>*dog</code>类型，所以不能给<code>x</code>传入<code>dog</code>类型的wangcai，此时x只能存储<code>*dog</code>类型的值。</p><h3 id="接口与类型的关系"><a href="#接口与类型的关系" class="headerlink" title="接口与类型的关系"></a>接口与类型的关系</h3><p>一个类型可以实现多个接口，一个接口可以被多个类型实现</p><h3 id="接口嵌套"><a href="#接口嵌套" class="headerlink" title="接口嵌套"></a>接口嵌套</h3><p>接口与接口只见可以实现嵌套的关系，一个接口可以存在于另一个接口内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sayer 接口</span></span><br><span class="line"><span class="keyword">type</span> Sayer <span class="keyword">interface</span> &#123;</span><br><span class="line">say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mover 接口</span></span><br><span class="line"><span class="keyword">type</span> Mover <span class="keyword">interface</span> &#123;</span><br><span class="line">move()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口嵌套</span></span><br><span class="line"><span class="keyword">type</span> animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Sayer</span><br><span class="line">Mover</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>空接口是指没有定义任何方法的接口，任何的类型都实现了空接口，空接口类型的变量可以存储任意类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义一个空接口x</span></span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">s := <span class="string">"Hello 沙河"</span></span><br><span class="line">x = s</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">i := <span class="number">100</span></span><br><span class="line">x = i</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">b := <span class="literal">true</span></span><br><span class="line">x = b</span><br><span class="line">fmt.Printf(<span class="string">"type:%T value:%v\n"</span>, x, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空接口作为函数的参数"><a href="#空接口作为函数的参数" class="headerlink" title="空接口作为函数的参数"></a>空接口作为函数的参数</h4><p>空接口可以用来当做函数参数类型，这样我们在给函数传入参数的时候可以不用考虑类型，任何类型都可以传入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variable_name</span><span class="params">(a <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="空接口作为map的值"><a href="#空接口作为map的值" class="headerlink" title="空接口作为map的值"></a>空接口作为map的值</h4><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空接口作为map值</span></span><br><span class="line"><span class="keyword">var</span> studentInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">studentInfo[<span class="string">"name"</span>] = <span class="string">"沙河娜扎"</span></span><br><span class="line">studentInfo[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line">studentInfo[<span class="string">"married"</span>] = <span class="literal">false</span></span><br><span class="line">fmt.Println(studentInfo)</span><br></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>空接口可以存储任意类型的值，那我们如何获取其存储的具体数据呢？</p><h4 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h4><p>一个接口的值（简称接口值）是由<code>一个具体类型</code>和<code>具体类型的值</code>两部分组成的。这两部分分别称为接口的<code>动态类型</code>和<code>动态值</code>。</p><p>我们来看一个具体的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> w io.Writer</span><br><span class="line">w = os.Stdout</span><br><span class="line">w = <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">w = <span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>请看下图分解：<img src="https://cdn.jsdelivr.net/gh/ThreerEyed/CDN/img/interface.png" alt=""></p><p>想要判断空接口中的值这个时候就可以使用类型断言，其语法格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.(T)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>x：表示类型为<code>interface{}</code>的变量</li><li>T：表示断言<code>x</code>可能是的类型。</li></ul><p>该语法返回两个参数，第一个参数是<code>x</code>转化为<code>T</code>类型后的变量，第二个值是一个布尔值，若为<code>true</code>则表示断言成功，为<code>false</code>则表示断言失败。</p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> x <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">x = <span class="string">"Hello 沙河"</span></span><br><span class="line">v, ok := x.(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"类型断言失败"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例中如果要断言多次就需要写多个<code>if</code>判断，这个时候我们可以使用<code>switch</code>语句来实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">justifyType</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">fmt.Printf(<span class="string">"x is a string，value is %v\n"</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Printf(<span class="string">"x is a int is %v\n"</span>, v)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">fmt.Printf(<span class="string">"x is a bool is %v\n"</span>, v)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"unsupport type！"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为空接口可以存储任意类型值的特点，所以空接口在Go语言中的使用十分广泛。</p><p>关于接口需要注意的是，只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要定义接口。不要为了接口而写接口，那样只会增加不必要的抽象，导致不必要的运行时损耗。</p><div class="note warning">            <p>文章部分内容来源于<a href="https://www.runoob.com/go/go-interfaces.html" target="_blank" rel="noopener">菜鸟教程</a>  <a href="https://www.liwenzhou.com/posts/Go/12_interface/" target="_blank" rel="noopener">李文周的博客</a></p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/go-basics/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day06（结构体）</title>
    <link href="http://threereyed.top/go-basics/Go-basics-day06/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day06/"/>
    <id>http://threereyed.top/go-basics/Go-basics-day06/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day06/</id>
    <published>2020-05-30T03:54:49.000Z</published>
    <updated>2020-06-02T07:36:20.174Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning">            <p>这是一个创建于 2020-05-27 22:31:21 的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><br/><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>在go 语言中，数组可以用来存储同一类型的数据，结构体可以用来存储不同类型的数据。</p><p>结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。</p><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><p>结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br><span class="line">或</span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> people <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="keyword">string</span></span><br><span class="line">age   <span class="keyword">int</span></span><br><span class="line">sex   <span class="keyword">string</span></span><br><span class="line">height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">people1 := people&#123;name: <span class="string">"张三"</span>, age: <span class="number">18</span>, sex: <span class="string">"男"</span>, height: <span class="number">173</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的结构体</span></span><br><span class="line">fmt.Println(people1)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用 key =&gt; value 格式</span></span><br><span class="line">fmt.Println(people&#123;name: <span class="string">"赵四"</span>, age: <span class="number">20</span>, sex: <span class="string">"男"</span>, height: <span class="number">165</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略的字段为 0 或 空</span></span><br><span class="line">fmt.Println(people&#123;name: <span class="string">"joe"</span>, age: <span class="number">18</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>{张三 18 男 173}<br>{赵四 20 男 165}<br>{joe 18  0}</p></blockquote><br/><h3 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h3><p>使用  <code>.</code> 来访问结构体成员，用法为：struct_name.成员名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">people1 := people&#123;name: <span class="string">"张三"</span>, age: <span class="number">18</span>, sex: <span class="string">"男"</span>, height: <span class="number">173</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(people1.name)</span><br></pre></td></tr></table></figure><p>运行结果为：</p><blockquote><p>张三</p></blockquote><br/><h3 id="结构体作为函数参数"><a href="#结构体作为函数参数" class="headerlink" title="结构体作为函数参数"></a>结构体作为函数参数</h3><p>结构体可以像其他数据类型一样当做参数传入函数，可以在函数内部通过<code>.</code>   的形式来传入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> peoples <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">age    <span class="keyword">int</span></span><br><span class="line">sex    <span class="keyword">string</span></span><br><span class="line">height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people1 peoples</span><br><span class="line"></span><br><span class="line">people1.name = <span class="string">"张三"</span></span><br><span class="line">people1.age = <span class="number">14</span></span><br><span class="line">people1.sex = <span class="string">"男"</span></span><br><span class="line">people1.height = <span class="number">165</span></span><br><span class="line"></span><br><span class="line">printPeople(people1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printPeople</span><span class="params">(person peoples)</span></span> &#123;</span><br><span class="line">fmt.Println(person.name)</span><br><span class="line">fmt.Println(person.age)</span><br><span class="line">fmt.Println(person.sex)</span><br><span class="line">fmt.Println(person.height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出结果为：</p><blockquote><p>张三<br>14<br>男<br>165</p></blockquote><br/><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>结构体类似其他类型的输出一样，定义指向结构体的指针，结构体是值传递类型，有时我们修改结构体内的成员值，需要通过指针来修改，通过struct类型的指针找到struct 类型的指针变量，再通过指针变量找到地址，然后修改值</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>创建一个新的对象，类似于python中的<code>__init__</code>, 创建对象并初始化赋值，总与new运算符一起使用在创建对象的语句中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> peoples <span class="keyword">struct</span> &#123;</span><br><span class="line">name   <span class="keyword">string</span></span><br><span class="line">age    <span class="keyword">int</span></span><br><span class="line">sex    <span class="keyword">string</span></span><br><span class="line">height <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPeoples</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>, sex <span class="keyword">string</span>, height <span class="keyword">int</span>)</span> <span class="title">peoples</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> peoples&#123;</span><br><span class="line">name:   name,</span><br><span class="line">age:    age,</span><br><span class="line">sex:    sex,</span><br><span class="line">height: height,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    p1 := newPeoples(<span class="string">"张三"</span>, <span class="number">27</span>, <span class="string">"男"</span>, <span class="number">187</span>)</span><br><span class="line">    fmt.Println(p1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体匿名字段"><a href="#结构体匿名字段" class="headerlink" title="结构体匿名字段"></a>结构体匿名字段</h2><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person 结构体Person类型</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="keyword">string</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p1 := Person&#123;</span><br><span class="line"><span class="string">"小王子"</span>,</span><br><span class="line"><span class="number">18</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, p1)        <span class="comment">//main.Person&#123;string:"北京", int:18&#125;</span></span><br><span class="line">fmt.Println(p1.<span class="keyword">string</span>, p1.<span class="keyword">int</span>) <span class="comment">//北京 18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名字段默认采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><p>匿名字段的使用场景较少，因为字段不能重复。</p><h2 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h2><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Address 地址结构体</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">Province <span class="keyword">string</span></span><br><span class="line">City     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//User 用户结构体</span></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="keyword">string</span></span><br><span class="line">Gender  <span class="keyword">string</span></span><br><span class="line">Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">user1 := User&#123;</span><br><span class="line">Name:   <span class="string">"小王子"</span>,</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">Address: Address&#123;</span><br><span class="line">Province: <span class="string">"山东"</span>,</span><br><span class="line">City:     <span class="string">"威海"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"user1=%#v\n"</span>, user1)<span class="comment">//user1=main.User&#123;Name:"小王子", Gender:"男", Address:main.Address&#123;Province:"山东", City:"威海"&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体继承"><a href="#结构体继承" class="headerlink" title="结构体继承"></a>结构体继承</h2><p>继承仍然是结构体的嵌套。</p><p>Go语言中使用结构体也可以实现其他编程语言中面向对象的继承。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Animal 动物</span></span><br><span class="line"><span class="keyword">type</span> Animal <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Animal)</span> <span class="title">move</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会动！\n"</span>, a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Dog 狗</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">Feet    <span class="keyword">int8</span></span><br><span class="line">*Animal <span class="comment">//通过嵌套匿名结构体实现继承</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span> <span class="title">wang</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s会汪汪汪~\n"</span>, d.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := &amp;Dog&#123;</span><br><span class="line">Feet: <span class="number">4</span>,</span><br><span class="line">Animal: &amp;Animal&#123; <span class="comment">//注意嵌套的是结构体指针</span></span><br><span class="line">name: <span class="string">"乐乐"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">d1.wang() <span class="comment">//乐乐会汪汪汪~</span></span><br><span class="line">d1.move() <span class="comment">//乐乐会动！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h2><p>结构体中字段大写开头表示可公开访问，小写表示私有（仅在定义当前结构体的包中可访问）。</p><h2 id="结构体与Json（avaScript-Object-Notation-JS-对象简谱-）"><a href="#结构体与Json（avaScript-Object-Notation-JS-对象简谱-）" class="headerlink" title="结构体与Json（avaScript Object Notation, JS 对象简谱 ）"></a>结构体与Json（avaScript Object Notation, JS 对象简谱 ）</h2><p>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。JSON键值对是用来保存JS对象的一种方式，键/值对组合中的键名写在前面并用双引号<code>&quot;&quot;</code>包裹，使用冒号<code>:</code>分隔，然后紧接着值；多个键值之间使用英文<code>,</code>分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student 学生</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">ID     <span class="keyword">int</span></span><br><span class="line">Gender <span class="keyword">string</span></span><br><span class="line">Name   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Class 班级</span></span><br><span class="line"><span class="keyword">type</span> Class <span class="keyword">struct</span> &#123;</span><br><span class="line">Title    <span class="keyword">string</span></span><br><span class="line">Students []*Student</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := &amp;Class&#123;</span><br><span class="line">Title:    <span class="string">"101"</span>,</span><br><span class="line">Students: <span class="built_in">make</span>([]*Student, <span class="number">0</span>, <span class="number">200</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">stu := &amp;Student&#123;</span><br><span class="line">Name:   fmt.Sprintf(<span class="string">"stu%02d"</span>, i),</span><br><span class="line">Gender: <span class="string">"男"</span>,</span><br><span class="line">ID:     i,</span><br><span class="line">&#125;</span><br><span class="line">c.Students = <span class="built_in">append</span>(c.Students, stu)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span></span><br><span class="line">data, err := json.Marshal(c)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json marshal failed"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"json:%s\n"</span>, data)</span><br><span class="line"><span class="comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span></span><br><span class="line">str := <span class="string">`&#123;"Title":"101","Students":[&#123;"ID":0,"Gender":"男","Name":"stu00"&#125;,&#123;"ID":1,"Gender":"男","Name":"stu01"&#125;,&#123;"ID":2,"Gender":"男","Name":"stu02"&#125;,&#123;"ID":3,"Gender":"男","Name":"stu03"&#125;,&#123;"ID":4,"Gender":"男","Name":"stu04"&#125;,&#123;"ID":5,"Gender":"男","Name":"stu05"&#125;,&#123;"ID":6,"Gender":"男","Name":"stu06"&#125;,&#123;"ID":7,"Gender":"男","Name":"stu07"&#125;,&#123;"ID":8,"Gender":"男","Name":"stu08"&#125;,&#123;"ID":9,"Gender":"男","Name":"stu09"&#125;]&#125;`</span></span><br><span class="line">c1 := &amp;Class&#123;&#125;</span><br><span class="line">err = json.Unmarshal([]<span class="keyword">byte</span>(str), c1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"json unmarshal failed!"</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, c1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note warning">            <p>本节部分内容来源于<a href="https://www.liwenzhou.com/posts/Go/10_struct/" target="_blank" rel="noopener">李文周的博客</a></p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/go-basics/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day05（指针，map，range）</title>
    <link href="http://threereyed.top/go-basics/Go-basics-day05/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day05/"/>
    <id>http://threereyed.top/go-basics/Go-basics-day05/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day05/</id>
    <published>2020-05-29T06:14:59.000Z</published>
    <updated>2020-06-02T07:36:31.743Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning">            <p>这是一个创建于 2020-05-29 14:14:59的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><br/><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><blockquote><p><strong>原文链接：</strong><a href="https://link.jianshu.com?t=https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back" target="_blank" rel="noopener">Understand Go pointers in less than 800 words or your money back</a></p></blockquote><p>这是一篇面向即将学习 go 语言并且对指针理念或者 go 的指针类型不是很了解的程序员的内容</p><br/><h3 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h3><p>简单解释，指针就是指向另一段地址的值，课本上是这么解释的，但是如果你是一个来自并不讨论变量地址开发语言的开发者，使用指针进行编程将感觉非常的美妙。</p><br/><p>我们先换一个话题</p><h3 id="什么是内存？"><a href="#什么是内存？" class="headerlink" title="什么是内存？"></a>什么是内存？</h3><p>计算机的内存 RAM 可以把它想象成一些有序的盒子，一个接一个的排成一排，每一个盒子或者单元格都被一个唯一的数字标记依次递增，这个数字就是该单元格的地址，也就是内存的地址。</p><p><img src="https://i.loli.net/2020/05/29/MFodZcxTshmjynJ.jpg" alt="img"></p><p>每一个单元格存储单一的值，如果你知道一个单元格的地址，那么你就可以通过地址读取单元格中的内容。你也可以向这个单元格中放置一个值来替代之前的任何值。</p><p>这就是关于内存的所有内容。CPU 所做的一切操作也都是在读取或者存储单元格中值。</p><br/><h3 id="什么是变量？"><a href="#什么是变量？" class="headerlink" title="什么是变量？"></a>什么是变量？</h3><p>编写一段程序，检索出值并存储在地址为 200 的一个块内存中，将其乘以 3，并将结果存储在地址为 201 的另一块内存中，我们就可以像这样写一段伪代码：</p><ol><li><p>检索出内存地址为 200 的值，并将其存储在 CPU 中</p></li><li><p>将存储在 CPU 中的值乘以 3</p></li><li><p>将 CPU 中存储的结果，写入地址为 201 的内存块中</p><p><img src="https://i.loli.net/2020/05/29/drpQl1FhRqiOmxs.jpg" alt="img"></p></li></ol><p>这是相当早期的编程形式，程序员需要维护一列内存地址，需要清楚的知道：谁、什么时候在使用它以及内存中存储的值是什么。</p><p>很显然这是非常枯燥又很容易出错的方式，并且还意味着你要为程序构建过程中内存中的每一个可能出现的值分配地址。更糟糕的是这种设计使得你动态的为变量分配存储变得很艰难，你可以想象一下如果编写一个大型的程序而只能使用全局变量是什么感受？</p><p>为了解决这个问题，变量的概念被创造了出来，一个变量仅仅是一个代表内存地址的字母数字组合、也可以一个标签或者一个昵称 。</p><p>现在，我们与其探讨内存地址，不如说一下变量，变量是我们为内存地址赋予的一个更容易理解的名称，之前的那个程序现在可以这样的解释一下：</p><p><img src="https://i.loli.net/2020/05/29/Fd9uvejL2NOKD1P.jpg" alt="img"></p><ol><li>获取变量 a 中存储的值，并将其存储在 CPU 中</li><li>将其乘以 3</li><li>将结果保存在变量 b 中</li></ol><p>这是一个相同的程序，唯一的一个重要改进是我们不在直接关注内存地址了，我们也不在需要持续追踪内存地址，而是把这个苦差事交给了编译器。</p><p>现在我们可以像这样写程序了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">6</span> </span><br><span class="line"><span class="keyword">var</span> b = a * <span class="number">3</span></span><br></pre></td></tr></table></figure><p>编译器将确保 a 与 b 的变量被分配唯一的地址，同时保证其值可以在被调用结束之前不被释放。</p><br/><h3 id="到底什么是指针呢？"><a href="#到底什么是指针呢？" class="headerlink" title="到底什么是指针呢？"></a>到底什么是指针呢？</h3><p>截止目前我们知道了内存就是一系列有序列号的存储单元，变量就是编译器为内存地址分配的昵称，那么指针是什么呢？</p><blockquote><p>指针就是一个指向另一个内存地址变量的值</p></blockquote><p>指针指向变量的内存地址，指针就像该变量值的内存地址一样</p><p>我们来看一个代码片段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">200</span></span><br><span class="line">    b := &amp;a</span><br><span class="line">    *b++</span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 main 函数的第一行，我们定义了一个新的变量 a ，并赋值为 200。接下来我们定义了一个变量 b ，并将变量 a 的地址赋值给 b 。我们并不知道 a 的准确存储地址，但是我们依然可以将 a 的地址存储在变量 b 中。</p></blockquote><p><img src="https://i.loli.net/2020/05/29/bSPQcL6CmwfThex.jpg" alt="img"></p><p><img src="https://i.loli.net/2020/05/29/GKewcBOox7UsFS8.jpg" alt="img"></p><p>因为 Go 强类型的特性，第三行代码也许是最具干扰性的了，b 包含 a 变量的地址，但是我们想增加存储在 a 变量中的值。这样我们必须取消引用 b ，而是跟随指针由 b 引用 a。<br> 然后我们将该值加 1 后，存储回 b 中存储的内存地址上。<br> 最后一行打印了 a 的值，可以看到 a 的值已经增加为了 201</p><p><img src="https://i.loli.net/2020/05/29/SVNgwbyoq81RIXu.jpg" alt="img"></p><p><img src="https://i.loli.net/2020/05/29/6opzHtAKVwJyXd8.jpg" alt="img"></p><br/><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>假如你是一个来自没有指针概念或者变量中隐藏了指针的开发语言的开发者，你需要在形成一个指针与变量关联关系的模型，总之记住这个规则：</p><blockquote><p>指针是一个指向另一个变量内存地址的值</p></blockquote><div class="note warning">            <p>以上关于指针的解释来源于 <a href="https://www.jianshu.com/p/44b9429d7bef" target="_blank" rel="noopener">https://www.jianshu.com/p/44b9429d7bef</a></p>          </div><br/><h3 id="amp-和"><a href="#amp-和" class="headerlink" title="&amp; 和 *"></a>&amp; 和 *</h3><p>&amp;：用来查找变量的内存地址</p><p>*：用来查找内存地址保存的值</p><p>用法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> b = &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"a 在内存中的地址是%v, 值是%v"</span>, b, *b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>a 在内存中的地址是0xc0000100b0, 值是20</p></blockquote><br/><h3 id="Go-空指针"><a href="#Go-空指针" class="headerlink" title="Go 空指针"></a>Go 空指针</h3><p>当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><p>nil 指针也称为空指针。</p><p>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。</p><p>一个指针变量通常缩写为 ptr。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span>  ptr *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"ptr 的值为 : %x\n"</span>, ptr  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>ptr 的值为 : &lt;nil&gt;</p></blockquote><br/><h3 id="Go指针更多内容"><a href="#Go指针更多内容" class="headerlink" title="Go指针更多内容"></a>Go指针更多内容</h3><p>接下来我们将为大家介绍Go语言中更多的指针应用：</p><table><thead><tr><th align="left">内容</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-array-of-pointers.html" target="_blank" rel="noopener">Go 指针数组</a></td><td align="left">你可以定义一个指针数组来存储地址</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-pointer-to-pointer.html" target="_blank" rel="noopener">Go 指向指针的指针</a></td><td align="left">Go 支持指向指针的指针</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-passing-pointers-to-functions.html" target="_blank" rel="noopener">Go 向函数传递指针参数</a></td><td align="left">通过引用或地址传参，在函数调用时可以改变其值</td></tr></tbody></table><br/><h2 id="make-和-new"><a href="#make-和-new" class="headerlink" title="make 和 new"></a>make 和 new</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new是一个内置的函数，它的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>Type表示类型，new函数只接受一个参数，这个参数是一个类型</li><li>*Type表示类型指针，new函数返回一个指向该类型内存地址的指针。</li></ul><p>new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">b := <span class="built_in">new</span>(<span class="keyword">bool</span>)</span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, a) <span class="comment">// *int</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, b) <span class="comment">// *bool</span></span><br><span class="line">fmt.Println(*a)       <span class="comment">// 0</span></span><br><span class="line">fmt.Println(*b)       <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make也是用于内存分配的，区别于new，它只用于slice、map以及chan的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。make函数的函数签名如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。</p><br/><h3 id="new与make的区别"><a href="#new与make的区别" class="headerlink" title="new与make的区别"></a>new与make的区别</h3><ol><li>二者都是用来做内存分配的。</li><li>make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；</li><li>而new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。</li></ol><br/><h2 id="map-集合"><a href="#map-集合" class="headerlink" title="map(集合)"></a>map(集合)</h2><p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p><p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的</p><br/><h3 id="定义map"><a href="#定义map" class="headerlink" title="定义map"></a>定义map</h3><p>上文我们学过make 函数，make是专门针对于 slice、map、chan的内存创建。</p><p>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 为map在程序中开辟内存空间*/</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure><p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p><br/><h3 id="map-运用"><a href="#map-运用" class="headerlink" title="map 运用"></a>map 运用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">/*创建集合 */</span></span><br><span class="line">    countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* map插入key - value对,各个国家对应的首都 */</span></span><br><span class="line">    countryCapitalMap [ <span class="string">"France"</span> ] = <span class="string">"巴黎"</span></span><br><span class="line">    countryCapitalMap [ <span class="string">"Italy"</span> ] = <span class="string">"罗马"</span></span><br><span class="line">    countryCapitalMap [ <span class="string">"Japan"</span> ] = <span class="string">"东京"</span></span><br><span class="line">    countryCapitalMap [ <span class="string">"India "</span> ] = <span class="string">"新德里"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*使用键输出地图值 */</span></span><br><span class="line">    <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">        fmt.Println(country, <span class="string">"首都是"</span>, countryCapitalMap [country])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*查看元素在集合中是否存在 */</span></span><br><span class="line">    capital, ok := countryCapitalMap [ <span class="string">"American"</span> ] <span class="comment">/*如果确定是真实的,则存在,否则不存在 */</span></span><br><span class="line">    <span class="comment">/*fmt.Println(capital) */</span></span><br><span class="line">    <span class="comment">/*fmt.Println(ok) */</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        fmt.Println(<span class="string">"American 的首都是"</span>, capital)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"American 的首都不存在"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例运行结果为：</p><blockquote><p>France 首都是 巴黎<br>Italy 首都是 罗马<br>Japan 首都是 东京<br>India  首都是 新德里<br>American 的首都不存在</p></blockquote><p>以上代码中<code>countryCapitalMap [ &quot;American&quot; ]</code> 返回一个value 和一个bool 值，go语言中约定成俗使用ok 来接受这个bool 值，判断这个ok的值，来判断是否存在这个key</p><br/><h3 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h3><p>可以使用range 来遍历map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> mapHanshu &#123;</span><br><span class="line">    fmt.Println(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br/><h3 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h3><p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">/* 创建map */</span></span><br><span class="line">        countryCapitalMap := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"France"</span>: <span class="string">"Paris"</span>, <span class="string">"Italy"</span>: <span class="string">"Rome"</span>, <span class="string">"Japan"</span>: <span class="string">"Tokyo"</span>, <span class="string">"India"</span>: <span class="string">"New delhi"</span>&#125;</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"原始地图"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 打印地图 */</span></span><br><span class="line">        <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">                fmt.Println(country, <span class="string">"首都是"</span>, countryCapitalMap [ country ])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*删除元素*/</span> <span class="built_in">delete</span>(countryCapitalMap, <span class="string">"France"</span>)</span><br><span class="line">        fmt.Println(<span class="string">"法国条目被删除"</span>)</span><br><span class="line"></span><br><span class="line">        fmt.Println(<span class="string">"删除元素后地图"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*打印地图*/</span></span><br><span class="line">        <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">                fmt.Println(country, <span class="string">"首都是"</span>, countryCapitalMap [ country ])</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>原始地图<br>India 首都是 New delhi<br>France 首都是 Paris<br>Italy 首都是 Rome<br>Japan 首都是 Tokyo<br>法国条目被删除<br>删除元素后地图<br>Italy 首都是 Rome<br>Japan 首都是 Tokyo<br>India 首都是 New delhi</p></blockquote><div class="note info">            <p>这里我们可以通过一个命令来查看一些函数的用法，命令如下：</p><p><code>go doc 包</code> 或者查看函数 <code>go doc 包名.函数名</code></p>          </div><p>例如：</p><blockquote><p>D:\Go\src\github.com\ThreeREyed\studygo\day05\pointer&gt;go doc fmt.Printf<br>package fmt // import “fmt”</p><p>func Printf(format string, a …interface{}) (n int, err error)<br>    Printf formats according to a format specifier and writes to standard<br>    output. It returns the number of bytes written and any write error<br>    encountered.</p><p>D:\Go\src\github.com\ThreeREyed\studygo\day05\pointer&gt;</p></blockquote><br/><h2 id="Go中的range"><a href="#Go中的range" class="headerlink" title="Go中的range"></a>Go中的range</h2><p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p><p>range 是一个关键字不是函数，所以在使用range的时候，直接在被range的容器前，使用range 关键字即可，一般用于for 循环中</p><br/><div class="note warning">            <p>本节部分内容来源于<a href="https://www.runoob.com/go/go-arrays.html" target="_blank" rel="noopener">菜鸟教程</a></p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/go-basics/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day04（数组、切片）</title>
    <link href="http://threereyed.top/go-basics/Go-basics-day04/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day04/"/>
    <id>http://threereyed.top/go-basics/Go-basics-day04/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day04/</id>
    <published>2020-05-27T14:31:21.000Z</published>
    <updated>2020-06-02T07:36:43.260Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning">            <p>这是一个创建于 2020-05-27 22:31:21 的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>Go 语言提供了数组类型的数据结构。</p><p>数组是具有相同唯一类型的一组已编号且长度固定的数据项序列，这种类型可以是任意的原始类型例如整形、字符串或者自定义类型。</p><p>数组元素可以通过索引（位置）来读取（或者修改），索引从 0 开始，第一个元素索引为 0，第二个索引为 1，以此类推。</p><h3 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h3><p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">3</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>初始化数组中 {} 中的元素个数不能大于 [] 中的数字。</p><p>如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>初始化数组的初始化有多种形式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为5的数组，其元素值依次为：1，2，3，4，5。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为 5 的数组，其元素值依次为：1，2，0，0，0 。</p><p>在初始化时没有指定初值的元素将会赋值为其元素类型 int 的默认值0，string 的默认值是 “”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为 5 的数组，其长度是根据初始化时指定的元素个数决定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5</span>] <span class="keyword">int</span> &#123; <span class="number">2</span>:<span class="number">1</span>,<span class="number">3</span>:<span class="number">2</span>,<span class="number">4</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为 5 的数组，key:value，其元素值依次为：0，0，1，2，3。在初始化时指定了 2，3，4 索引中对应的值：1，2，3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...] <span class="keyword">int</span> &#123;<span class="number">2</span>:<span class="number">1</span>,<span class="number">4</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>长度为5的数组，起元素值依次为：0，0，1，0，3。由于指定了最大索引 4 对应的值 3，根据初始化的元素个 数确定其长度为5赋值与使用。</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>数组元素可以通过索引（位置）来读取。格式为数组名后加中括号，中括号中为索引的值。例如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.<span class="built_in">println</span>(array[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片是由数组引出的，因为数组的长度是固定不变的，有的时候我们需要一个可变的元素集合，这个时候就有了动态数组，也就是切片。</p><p>内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。</p><p>切片由三部分组成：指向底层数组的指针、len、cap。</p><h3 id="切片的定义"><a href="#切片的定义" class="headerlink" title="切片的定义"></a>切片的定义</h3><p>切片有两种定义方式</p><h4 id="声明一个没有大小的数组来定义切片"><a href="#声明一个没有大小的数组来定义切片" class="headerlink" title="声明一个没有大小的数组来定义切片"></a>声明一个没有大小的数组来定义切片</h4><p>不需要说明长度[] 内没有数值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><h4 id="使用make-函数来定义"><a href="#使用make-函数来定义" class="headerlink" title="使用make() 函数来定义"></a>使用<code>make()</code> 函数来定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">slice1 :=  <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> makeSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">var</span> makeSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(makeSlice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>[0 0 0 0 0]</p></blockquote><h3 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><p>直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:]</span><br></pre></td></tr></table></figure><p>初始化切片s, 是数组arr的引用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[startIndex:]</span><br></pre></td></tr></table></figure><p>默认 endIndex 时将表示一直到arr的最后一个元素</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := arr[:endIndex]</span><br></pre></td></tr></table></figure><p>默认 startIndex 时将表示从arr的第一个元素开始</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := s[startIndex:endIndex]</span><br></pre></td></tr></table></figure><p>通过切片s初始化切片s1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure><p>注意： </p><p>切片有两种方式，一种是make创建或者声明[]int，另一种是通过数组切片获得，切片是对数组的引用，采用的是引用传递，当给切片赋值后，底层的数组也会发生改变</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> makeSlice = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(makeSlice)</span><br><span class="line"></span><br><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"a 的类型是%T\n"</span>, a)</span><br><span class="line"></span><br><span class="line">b := a[:]</span><br><span class="line">fmt.Printf(<span class="string">"b 的类型是%T, 值是%v\n"</span>, b, b)</span><br><span class="line"></span><br><span class="line">b[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"b 的类型是%T, 值是%v\n"</span>, b, b)</span><br><span class="line">fmt.Printf(<span class="string">"a 的类型是%T, 值是%v\n"</span>, a, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>[0 0 0 0 0]<br>a 的类型是[5]int<br>b 的类型是[]int, 值是[1 2 3 4 5]<br>b 的类型是[]int, 值是[10 2 3 4 5]<br>a 的类型是[5]int, 值是[10 2 3 4 5]</p></blockquote><h3 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h3><p>切片是可索引的，并且可以由 len() 方法获取长度。</p><p>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lenth := <span class="built_in">len</span>(b)</span><br><span class="line">capB := <span class="built_in">cap</span>(b)</span><br><span class="line">fmt.Printf(<span class="string">"len(b)=%v, cap(b)=%v\n"</span>, lenth, capB)</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>len(b)=5, cap(b)=5</p></blockquote><h3 id="空的切片"><a href="#空的切片" class="headerlink" title="空的切片"></a>空的切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c []<span class="keyword">int</span></span><br><span class="line">fmt.Printf(<span class="string">"c 的类型是%T，值是%v"</span>, c, c)</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>c 的类型是[]int，值是[]</p></blockquote><h3 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h3><p>切片的底层是数组，基于数组构建</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 创建切片 */</span></span><br><span class="line">   numbers := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;  </span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印原始切片 */</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers =="</span>, numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引1(包含) 到索引4(不包含)*/</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers[1:4] =="</span>, numbers[<span class="number">1</span>:<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认下限为 0*/</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers[:3] =="</span>, numbers[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 默认上限为 len(s)*/</span></span><br><span class="line">   fmt.Println(<span class="string">"numbers[4:] =="</span>, numbers[<span class="number">4</span>:])</span><br><span class="line"></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">   printSlice(numbers1)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引  0(包含) 到索引 2(不包含) */</span></span><br><span class="line">   number2 := numbers[:<span class="number">2</span>]</span><br><span class="line">   printSlice(number2)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 打印子切片从索引 2(包含) 到索引 5(不包含) */</span></span><br><span class="line">   number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">   printSlice(number3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]<br>numbers == [0 1 2 3 4 5 6 7 8]<br>numbers[1:4] == [1 2 3]<br>numbers[:3] == [0 1 2]<br>numbers[4:] == [4 5 6 7 8]<br>len=0 cap=5 slice=[]<br>len=2 cap=9 slice=[0 1]<br>len=3 cap=7 slice=[2 3 4]</p></blockquote><p>注意：</p><p>在以上代码中我们发现最后一个number3 的输出和cap 发现cap发生改变，这是go的切片特性，在从索引0以后进行切片时，容量会发生改变，改变值取决于索引从哪开始 </p><h3 id="append-和-copy-函数"><a href="#append-和-copy-函数" class="headerlink" title="append() 和 copy() 函数"></a>append() 和 copy() 函数</h3><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。</p><p>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">   numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">   printSlice(numbers)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">   numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line">   <span class="built_in">copy</span>(numbers1,numbers)</span><br><span class="line">   printSlice(numbers1)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(x []<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">   fmt.Printf(<span class="string">"len=%d cap=%d slice=%v\n"</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>len=0 cap=0 slice=[]<br>len=1 cap=1 slice=[0]<br>len=2 cap=2 slice=[0 1]<br>len=5 cap=6 slice=[0 1 2 3 4]<br>len=5 cap=12 slice=[0 1 2 3 4]</p></blockquote><p>对于同时添加多个元素之后，我们发现初始切片的容量发生了改变，而且这个改变似乎有迹可循，这里对于append 多个元素这里有些规则</p><h4 id="添加较少的元素，一次性只添加一个元素"><a href="#添加较少的元素，一次性只添加一个元素" class="headerlink" title="添加较少的元素，一次性只添加一个元素"></a>添加较少的元素，一次性只添加一个元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    a = <span class="built_in">append</span>(a, i)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(a), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 4 4 8 8 8 8 16 16 16 16 16 16 16 16</span></span><br></pre></td></tr></table></figure><h4 id="一次性添加多个元素"><a href="#一次性添加多个元素" class="headerlink" title="一次性添加多个元素"></a>一次性添加多个元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(a), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6 12 24 24 48 48 48 48 48 96 96 96 96 96 96 96</span></span><br><span class="line"></span><br><span class="line">c := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line">d := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"len(c)=%v, cap(c)=%v, %v\n"</span>, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c), c)</span><br><span class="line">c = <span class="built_in">append</span>(c, d...)</span><br><span class="line">fmt.Printf(<span class="string">"len(c)=%v, cap(c)=%v, %v\n"</span>, <span class="built_in">len</span>(c), <span class="built_in">cap</span>(c), c)</span><br><span class="line"><span class="comment">// len(c)=9, cap(c)=10, [1 3 1 2 3 4 5 6 7]</span></span><br></pre></td></tr></table></figure><p>如上代码所示，当我们初始化一个空的切片，然后不断使用append 向其中添加元素，然后查看切片a的容量改变，可以发现，在容量未满之前，容量不变</p><p>但是不同的元素类型会有不同的扩容情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int8</span></span><br><span class="line">a := []<span class="keyword">int8</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    a = <span class="built_in">append</span>(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(a), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8 16 32 32 32 64 64 64 64 64 128 128 128 128 128 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// int16</span></span><br><span class="line">fmt.Println()</span><br><span class="line">b := []<span class="keyword">int16</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    b = <span class="built_in">append</span>(b, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(b), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8 16 32 32 32 64 64 64 64 64 128 128 128 128 128 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bool</span></span><br><span class="line">fmt.Println()</span><br><span class="line">c := []<span class="keyword">bool</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    c = <span class="built_in">append</span>(c, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(c), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8 16 32 32 32 64 64 64 64 64 128 128 128 128 128 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float32</span></span><br><span class="line">fmt.Println()</span><br><span class="line">d := []<span class="keyword">float32</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    d = <span class="built_in">append</span>(d, <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(d), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 8 16 16 32 32 32 64 64 64 64 64 64 128 128 128 128 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// float64</span></span><br><span class="line">fmt.Println()</span><br><span class="line">e := []<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    e = <span class="built_in">append</span>(e, <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(e), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6 12 24 24 48 48 48 48 48 96 96 96 96 96 96 96 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line">fmt.Println()</span><br><span class="line">f := []<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    f = <span class="built_in">append</span>(f, <span class="string">"1.1"</span>, <span class="string">"2.2"</span>, <span class="string">"3.3"</span>, <span class="string">"4.4"</span>, <span class="string">"5.5"</span>)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(f), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 10 20 20 40 40 40 40 80 80 80 80 80 80 80 80 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// []int</span></span><br><span class="line">fmt.Println()</span><br><span class="line">g := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">g1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line">    g = <span class="built_in">append</span>(g, g1, g1, g1, g1, g1)</span><br><span class="line">    fmt.Print(<span class="built_in">cap</span>(g), <span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 5 10 20 20 42 42 42 42 85 85 85 85 85 85 85 85</span></span><br></pre></td></tr></table></figure><p>以上关于append 的代码来源于<a href="https://www.jianshu.com/p/54be5b08a21c" target="_blank" rel="noopener">吴子寒的博客</a></p><p>关于append 的扩容策略，还请参照源码，网上诸多答案，再加上我自行测试之后，发现都不是很正确，总有不对的地方，所以只能通过源码来看底层策略是如何做的，初学者应该把更多的时间花在其他的方面</p><h4 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy() 函数"></a>copy() 函数</h4><p>copy 函数可以将一个sliece 复制给另一个slice</p><p><strong>数组切片内容复制</strong></p><p>用于将内容从一个数组切片复制到另一个数组切片。如果加入的两个数组切片不一样大，就会按其中较小的那个数组切片的元素个数进行复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">slice1 :&#x3D; []int&#123;1, 2, 3, 4, 5&#125; </span><br><span class="line">slice2 :&#x3D; []int&#123;5, 4, 3&#125; </span><br><span class="line"></span><br><span class="line">copy(slice2, slice1) &#x2F;&#x2F; 只会复制slice1的前3个元素到slice2中 </span><br><span class="line">copy(slice1, slice2) &#x2F;&#x2F; 只会复制slice2的3个元素到slice1的前3个位置</span><br></pre></td></tr></table></figure><p>copy 函数会创建一个新的数组</p><div class="note warning">            <p>本节部分内容来源于<a href="https://www.runoob.com/go/go-arrays.html" target="_blank" rel="noopener">菜鸟教程</a></p>          </div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/go-basics/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day03（流程控制、运算符、函数）</title>
    <link href="http://threereyed.top/go-basics/Go-basics-day03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day03/"/>
    <id>http://threereyed.top/go-basics/Go-basics-day03/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day03/</id>
    <published>2020-05-26T10:03:31.000Z</published>
    <updated>2020-06-02T07:36:53.923Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning">            <p>这是一个创建于 2020-05-26 18:03:31 的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>golang是一种强类型语言，虽然在代码中经常看到这种写法，<code>i:=10</code>这其实这是编译器自动做了类型推断在编译期间。编译器会对数据进行类型检查。不同类型的数据不能赋值,不能在函数中传参。强类型语言有一些优势，很多的错误会在编译期间被检查出来，不想php和python等弱类型语言，很多错误只有运行到才能被发现。同样，强类型也有一些缺点，写代码的时候要考虑数据类型了，失去了一些灵活性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.6</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Println (a * b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码会报错，因为类型不匹配<br>这时候需要强制类型转换</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">5.6</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">    fmt.Println (a * <span class="keyword">float32</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不会报错了<br>普通变量类型<strong>int,float,string</strong> 都可以使用 <code>type (a)</code>这种形式来进行强制类型转换,比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int32</span>  = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int64</span> = <span class="keyword">int64</span>(a)</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = <span class="number">12.3</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">float64</span> =<span class="keyword">float64</span>(c)</span><br></pre></td></tr></table></figure><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="go语言条件语句"><a href="#go语言条件语句" class="headerlink" title="go语言条件语句"></a>go语言条件语句</h3><p>条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句</p><table><thead><tr><th align="left">语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-if-statement.html" target="_blank" rel="noopener">if 语句</a></td><td align="left"><strong>if 语句</strong> 由一个布尔表达式后紧跟一个或多个语句组成。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-if-else-statement.html" target="_blank" rel="noopener">if…else 语句</a></td><td align="left"><strong>if 语句</strong> 后可以使用可选的 <strong>else 语句</strong>, else 语句中的表达式在布尔表达式为 false 时执行。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-nested-if-statements.html" target="_blank" rel="noopener">if 嵌套语句</a></td><td align="left">你可以在 <strong>if</strong> 或 <strong>else if</strong> 语句中嵌入一个或多个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-switch-statement.html" target="_blank" rel="noopener">switch 语句</a></td><td align="left"><strong>switch</strong> 语句用于基于不同条件执行不同动作。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-select-statement.html" target="_blank" rel="noopener">select 语句</a></td><td align="left"><strong>select</strong> 语句类似于 <strong>switch</strong> 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</td></tr></tbody></table><blockquote><p>注意：Go 没有三目运算符，所以不支持 <strong>?:</strong> 形式的条件判断。</p></blockquote><p><strong>f 语句使用 tips</strong>：</p><p><strong>（1）</strong> 不需使用括号将条件包含起来</p><p><strong>（2）</strong> 大括号{}必须存在，即使只有一行语句</p><p><strong>（3）</strong> 左括号必须在if或else的同一行</p><p><strong>（4）</strong> 在if之后，条件语句之前，可以添加变量初始化语句，使用；进行分隔，并且该变量只作用于该if 条件语句中（作用域）</p><p><strong>（5）</strong> 在有返回值的函数中，最终的return不能在条件语句中</p><h3 id="go-语言循环语句"><a href="#go-语言循环语句" class="headerlink" title="go 语言循环语句"></a>go 语言循环语句</h3><p>Go 语言提供了以下几种类型循环处理语句：</p><table><thead><tr><th align="left">循环类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-for-loop.html" target="_blank" rel="noopener">for 循环</a></td><td align="left">重复执行语句块</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-nested-loops.html" target="_blank" rel="noopener">循环嵌套</a></td><td align="left">在 for 循环中嵌套一个或多个 for 循环</td></tr></tbody></table><p>使用for 循环打印九九乘法表</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 打印九九乘法表</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i+<span class="number">1</span>; j++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%dx%d=%d "</span>, j, i, i*j)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">" "</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>1x1=1<br>1x2=2 2x2=4<br>1x3=3 2x3=6 3x3=9<br>1x4=4 2x4=8 3x4=12 4x4=16<br>1x5=5 2x5=10 3x5=15 4x5=20 5x5=25<br>1x6=6 2x6=12 3x6=18 4x6=24 5x6=30 6x6=36<br>1x7=7 2x7=14 3x7=21 4x7=28 5x7=35 6x7=42 7x7=49<br>1x8=8 2x8=16 3x8=24 4x8=32 5x8=40 6x8=48 7x8=56 8x8=64<br>1x9=9 2x9=18 3x9=27 4x9=36 5x9=45 6x9=54 7x9=63 8x9=72 9x9=81</p></blockquote><p>程序理解：</p><p>程序自伤而下运行，当执行到外层for 循环的时候，设置变量i 初始值为1，如果 i &lt; 10 则在本次循环结束之后递增加1，i++ 是在本次循环执行语句完成之后再执行，给定 j 初始值为1，此时1 &lt; 1 + 1成立，执行语句输出，1 x 1 = 1，然后内层for循环的j 再加 1，此时 2 &lt; 1 + 1 不成立，跳出内层for循环，打印换行，再执行外层循环，此时的i == 2，然后依次执行…..</p><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>循环控制语句可以控制循环体内语句的执行过程。</p><p>GO 语言支持以下几种循环控制语句：</p><table><thead><tr><th align="left">控制语句</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-break-statement.html" target="_blank" rel="noopener">break 语句</a></td><td align="left">经常用于中断当前 for 循环或跳出 switch 语句</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-continue-statement.html" target="_blank" rel="noopener">continue 语句</a></td><td align="left">跳过当前循环的剩余语句，然后继续进行下一轮循环。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-goto-statement.html" target="_blank" rel="noopener">goto 语句</a></td><td align="left">将控制转移到被标记的语句。</td></tr></tbody></table><p>break：跳出本层循环，继续往下执行循环之外的代码</p><p>continue：跳出本次循环，执行本层循环的下一次循环</p><p>goto：跳出多层循环，跳到指定label（标签）</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符用于在程序运行时执行数学或逻辑运算。</p><p>Go 语言内置的运算符有：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">相加</td><td align="left">A + B 输出结果 30</td></tr><tr><td align="left">-</td><td align="left">相减</td><td align="left">A - B 输出结果 -10</td></tr><tr><td align="left">*</td><td align="left">相乘</td><td align="left">A * B 输出结果 200</td></tr><tr><td align="left">/</td><td align="left">相除</td><td align="left">B / A 输出结果 2</td></tr><tr><td align="left">%</td><td align="left">求余</td><td align="left">B % A 输出结果 0</td></tr><tr><td align="left">++</td><td align="left">自增</td><td align="left">A++ 输出结果 11</td></tr><tr><td align="left">–</td><td align="left">自减</td><td align="left">A– 输出结果 9</td></tr></tbody></table><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">检查两个值是否相等，如果相等返回 True 否则返回 False。</td><td align="left">(A == B) 为 False</td></tr><tr><td align="left">!=</td><td align="left">检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td><td align="left">(A != B) 为 True</td></tr><tr><td align="left">&gt;</td><td align="left">检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &gt; B) 为 False</td></tr><tr><td align="left">&lt;</td><td align="left">检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &lt; B) 为 True</td></tr><tr><td align="left">&gt;=</td><td align="left">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &gt;= B) 为 False</td></tr><tr><td align="left">&lt;=</td><td align="left">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td><td align="left">(A &lt;= B) 为 True</td></tr></tbody></table><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;&amp;</td><td align="left">逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。</td><td align="left">(A &amp;&amp; B) 为 False</td></tr><tr><td align="left">||</td><td align="left">逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。</td><td align="left">(A || B) 为 True</td></tr><tr><td align="left">!</td><td align="left">逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。</td><td align="left">!(A &amp;&amp; B) 为 True</td></tr></tbody></table><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位运算符对整数在内存中的二进制位进行操作。</p><p>下表列出了位运算符 &amp;, |, 和 ^ 的计算：</p><table><thead><tr><th align="left">p</th><th align="left">q</th><th align="left">p &amp; q</th><th align="left">p | q</th><th align="left">p ^ q</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr></tbody></table><p>Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。</td><td align="left">(A &amp; B) 结果为 12, 二进制为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符”|”是双目运算符。 其功能是参与运算的两数各对应的二进位相或</td><td align="left">(A | B) 结果为 61, 二进制为 0011 1101</td></tr><tr><td align="left">^</td><td align="left">按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。</td><td align="left">(A ^ B) 结果为 49, 二进制为 0011 0001</td></tr><tr><td align="left">&lt;&lt;</td><td align="left">左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td><td align="left">A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。</td><td align="left">A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</td></tr></tbody></table><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>下表列出了所有Go语言的赋值运算符。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td><td align="left">C = A + B 将 A + B 表达式结果赋值给 C</td></tr><tr><td align="left">+=</td><td align="left">相加后再赋值</td><td align="left">C += A 等于 C = C + A</td></tr><tr><td align="left">-=</td><td align="left">相减后再赋值</td><td align="left">C -= A 等于 C = C - A</td></tr><tr><td align="left">*=</td><td align="left">相乘后再赋值</td><td align="left">C *= A 等于 C = C * A</td></tr><tr><td align="left">/=</td><td align="left">相除后再赋值</td><td align="left">C /= A 等于 C = C / A</td></tr><tr><td align="left">%=</td><td align="left">求余后再赋值</td><td align="left">C %= A 等于 C = C % A</td></tr><tr><td align="left">&lt;&lt;=</td><td align="left">左移后赋值</td><td align="left">C &lt;&lt;= 2 等于 C = C &lt;&lt; 2</td></tr><tr><td align="left">&gt;&gt;=</td><td align="left">右移后赋值</td><td align="left">C &gt;&gt;= 2 等于 C = C &gt;&gt; 2</td></tr><tr><td align="left">&amp;=</td><td align="left">按位与后赋值</td><td align="left">C &amp;= 2 等于 C = C &amp; 2</td></tr><tr><td align="left">^=</td><td align="left">按位异或后赋值</td><td align="left">C ^= 2 等于 C = C ^ 2</td></tr><tr><td align="left">|=</td><td align="left">按位或后赋值</td><td align="left">C |= 2 等于 C = C | 2</td></tr></tbody></table><h3 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h3><p>下表列出了Go语言的其他运算符。</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">返回变量存储地址</td><td align="left">&a; 将给出变量的实际地址。</td></tr><tr><td align="left">*</td><td align="left">指针变量。</td><td align="left">*a; 是一个指针变量</td></tr></tbody></table><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">float32</span></span><br><span class="line">  <span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">  */\* 运算符实例 \*<span class="comment">/*</span></span><br><span class="line"><span class="comment">  fmt.Printf("第 1 行 - a 变量类型为 = %T\n", a );</span></span><br><span class="line"><span class="comment">  fmt.Printf("第 2 行 - b 变量类型为 = %T\n", b );</span></span><br><span class="line"><span class="comment">  fmt.Printf("第 3 行 - c 变量类型为 = %T\n", c );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span>\*  &amp; 和 \* 运算符实例 \*<span class="comment">/*</span></span><br><span class="line"><span class="comment">  ptr = &amp;a   */</span>\* <span class="string">'ptr'</span> 包含了 <span class="string">'a'</span> 变量的地址 \*<span class="comment">/*</span></span><br><span class="line"><span class="comment">  fmt.Printf("a 的值为  %d\n", a);</span></span><br><span class="line"><span class="comment">  fmt.Printf("*ptr 为 %d\n", *ptr);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>以上实例运行结果：</p><blockquote><p>第 1 行 - a 变量类型为 = int<br>第 2 行 - b 变量类型为 = int32<br>第 3 行 - c 变量类型为 = float32<br>a 的值为  4<br>*ptr 为 4</p></blockquote><p>指针变量 <strong>*** 和地址值 **&amp;</strong> 的区别：指针变量保存的是一个地址值，会分配独立的内存来存储一个整型数字。当变量前面有 <strong>*** 标识时，才等同于 **&amp;</strong> 的用法，否则会直接输出一个整型数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line">   <span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line">   ptr = &amp;a</span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"a的值为"</span>, a);    <span class="comment">// 4</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"*ptr为"</span>, *ptr);  <span class="comment">// 4</span></span><br><span class="line">   <span class="built_in">println</span>(<span class="string">"ptr为"</span>, ptr);    <span class="comment">// 824633794744</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><table><thead><tr><th align="left">优先级</th><th align="left">运算符</th></tr></thead><tbody><tr><td align="left">5</td><td align="left">* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td></tr><tr><td align="left">4</td><td align="left">+ - | ^</td></tr><tr><td align="left">3</td><td align="left">== != &lt; &lt;= &gt; &gt;=</td></tr><tr><td align="left">2</td><td align="left">&amp;&amp;</td></tr><tr><td align="left">1</td><td align="left">||</td></tr></tbody></table><p>当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是基本的代码块，用于执行一个任务。</p><p>Go 语言最少有个 main() 函数。</p><p>你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。</p><p>函数声明告诉了编译器函数的名称，返回类型，和参数。</p><p>Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。</p><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><p>Go 语言函数定义格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数定义解析：</p><ul><li>func：函数由 func 开始声明</li><li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li><li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li><li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li><li>函数体：函数定义的代码集合。</li></ul><p>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">result = a + b</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addNum</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">result = a + b</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">result = addNum(a, b)</span><br><span class="line">fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>300</p></blockquote><h3 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h3><p>Go 函数可以返回多个值，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  a, b := swap(<span class="string">"Google"</span>, <span class="string">"Runoob"</span>)</span><br><span class="line">  fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>函数如果使用参数，该变量可称为函数的形参。</p><p>形参就像定义在函数体内的局部变量。</p><p>调用函数，可以通过两种方式来传递参数：</p><table><thead><tr><th align="left">传递类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-function-call-by-value.html" target="_blank" rel="noopener">值传递</a></td><td align="left">值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-function-call-by-reference.html" target="_blank" rel="noopener">引用传递</a></td><td align="left">引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</td></tr></tbody></table><p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p><hr><h3 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h3><table><thead><tr><th align="left">函数用法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><a href="https://www.runoob.com/go/go-function-as-values.html" target="_blank" rel="noopener">函数作为另外一个函数的实参</a></td><td align="left">函数定义后可作为另外一个函数的实参数传入</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-function-closures.html" target="_blank" rel="noopener">闭包</a></td><td align="left">闭包是匿名函数，可在动态编程中使用</td></tr><tr><td align="left"><a href="https://www.runoob.com/go/go-method.html" target="_blank" rel="noopener">方法</a></td><td align="left">方法就是一个包含了接受者的函数</td></tr></tbody></table><div class="note warning">            <p>本节内容引自<a href="https://www.runoob.com/go/go-decision-making.html" target="_blank" rel="noopener">菜鸟教程</a> </p>          </div>]]></content>
    
    <summary type="html">
    
      关于Go语言的基础学习
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/go-basics/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day02（数据类型、变量、常量）</title>
    <link href="http://threereyed.top/go-basics/Go-basics-day02/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day02/"/>
    <id>http://threereyed.top/go-basics/Go-basics-day02/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day02/</id>
    <published>2020-05-25T01:57:50.000Z</published>
    <updated>2020-06-02T07:37:04.977Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning">            <p>这是一个创建于 2020-05-25 的文章，其中的信息可能已经有所发展或是发生改变。</p>          </div><h2 id="Go语言关键字"><a href="#Go语言关键字" class="headerlink" title="Go语言关键字"></a>Go语言关键字</h2><h3 id="go的25个关键字"><a href="#go的25个关键字" class="headerlink" title="go的25个关键字"></a>go的25个关键字</h3><p>break default func interface select<br>case defer go map struct<br>chan else goto package switch<br>const fallthrough if range type<br>continue for import return var</p><h3 id="关键词解释"><a href="#关键词解释" class="headerlink" title="关键词解释"></a>关键词解释</h3><p>1.break：break 用于跳出循环<br>2.default：用于选择结构的默认选项（switch、select）<br>3.func：函数定义<br>4.interface：定义接口<br>5.select：go语言特有的channel选择结构<br>6.case：选择结构标签<br>7.chan：定义channel<br>8.const：常量<br>9.continue：跳过本次循环<br>10.defer：延迟执行内容（收尾工作）有点类似C++的析构，但是它是再函数结尾的时候去执行（也就是栈即将被释放的时候）<br>11.go：并发执行<br>12.map：map类型<br>13.struct：定义结构体<br>14.else：选择结构<br>15.goto：跳转语句<br>16.package：包<br>17.switch：选择结构<br>18.fallthrough：如果case带有fallthrough，程序会继续执行下一条case,不会再判断下一条case的值<br>19.if：选择结构<br>20.range：从slice、map等结构中取元素<br>21.type：定义类型<br>22.for：循环<br>23.import：导入包<br>24.return：返回<br>25.var：定义变量</p><h3 id="go的保留字"><a href="#go的保留字" class="headerlink" title="go的保留字"></a>go的保留字</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Constants:    <span class="literal">true</span>  <span class="literal">false</span>  <span class="literal">iota</span>  <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">Types:    <span class="keyword">int</span>  <span class="keyword">int8</span>  <span class="keyword">int16</span>  <span class="keyword">int32</span>  <span class="keyword">int64</span>  </span><br><span class="line"><span class="keyword">uint</span>  <span class="keyword">uint8</span>  <span class="keyword">uint16</span>  <span class="keyword">uint32</span>  <span class="keyword">uint64</span>  <span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">float32</span>  <span class="keyword">float64</span>  <span class="keyword">complex128</span>  <span class="keyword">complex64</span></span><br><span class="line"><span class="keyword">bool</span>  <span class="keyword">byte</span>  <span class="keyword">rune</span>  <span class="keyword">string</span>  error</span><br><span class="line"></span><br><span class="line">Functions:   <span class="built_in">make</span>  <span class="built_in">len</span>  <span class="built_in">cap</span>  <span class="built_in">new</span>  <span class="built_in">append</span>  <span class="built_in">copy</span>  <span class="built_in">close</span>  <span class="built_in">delete</span></span><br><span class="line"><span class="built_in">complex</span>  <span class="built_in">real</span>  <span class="built_in">imag</span></span><br><span class="line"><span class="built_in">panic</span>  <span class="built_in">recover</span></span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><p>Go 语言按类别有以下几种数据类型：</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td></tr><tr><td align="left">2</td><td align="left"><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td></tr><tr><td align="left">3</td><td align="left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td></tr><tr><td align="left">4</td><td align="left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型</td></tr></tbody></table><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td></tr><tr><td align="left">2</td><td align="left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td></tr><tr><td align="left">3</td><td align="left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td align="left">4</td><td align="left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td align="left">5</td><td align="left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td></tr><tr><td align="left">6</td><td align="left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td align="left">7</td><td align="left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="left">8</td><td align="left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td></tr><tr><td align="left">2</td><td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td></tr><tr><td align="left">3</td><td align="left"><strong>complex64</strong> 32 位实数和虚数</td></tr><tr><td align="left">4</td><td align="left"><strong>complex128</strong> 64 位实数和虚数</td></tr></tbody></table><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>同python 语言不太一样，go语言中的布尔型true 和 false不等于0 和 1，在python 中，True  == 1 False == 0</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>go语言中的字符串是由双引号包含的，单引号包含的是int32 类型，不是字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'b'</span></span><br><span class="line">fmt.Println(reflect.TypeOf(a).Kind())</span><br><span class="line"></span><br><span class="line">b := <span class="string">"threereyed"</span></span><br><span class="line">fmt.Println(reflect.TypeOf(b).Kind())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出为</p><blockquote><p>int32<br>string</p></blockquote><h3 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h3><p><strong>（1）func HasPrefix(s, prefix string) bool</strong></p><p>判断字符串s是否有前缀字符串prefix</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="string">"threereyed"</span></span><br><span class="line"><span class="comment">// 判断字符串中是否以指定字符串开头</span></span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">"th"</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">"ht"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>true</p><p>false</p></blockquote><p><strong>（2）func HasSuffix(s, suffix string) bool</strong></p><p>判断字符串s是否有后缀字符串suffix</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串中是否以指定字符串结尾</span></span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">"ed"</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">"sa"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>ture</p><p>false</p></blockquote><p><strong>（3）func Contains(s, substr string) bool</strong></p><p>判断字符串s是否包含子串substr</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串中是否包含某个字符串</span></span><br><span class="line">fmt.Println(strings.Contains(a, <span class="string">"ree"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>true</p></blockquote><p><strong>（4）func Count(s, sep string) int</strong></p><p>返回字符串s有几个不重复sep子串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串中有几个指定的字符串</span></span><br><span class="line">fmt.Println(strings.Count(a, <span class="string">"e"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>4</p></blockquote><p><strong>（5）func Index(s, sep string) int</strong></p><p>返回字符串s中子串sep第一次出现的位置；不存在返回-1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串中指定字符串第一次出现的位置</span></span><br><span class="line">fmt.Println(strings.Index(a, <span class="string">"e"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>3</p></blockquote><p><strong>（6）func ToLower(s string) string</strong></p><p>返回字符串s转小写的拷贝；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="string">"ThreeREyeD"</span></span><br><span class="line"><span class="comment">// 返回转小写后的字符串</span></span><br><span class="line">fmt.Println(strings.ToLower(b))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>threereyed</p></blockquote><p><strong>（7）func ToUpper(s string) string</strong></p><p>返回字符串s转大写的拷贝</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回转大写后的字符串</span></span><br><span class="line">fmt.Println(strings.ToUpper(b))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>THREEREYED</p></blockquote><p><strong>（8）func Repeat(s string, count int) string</strong></p><p>返回count个字符串s串联的字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将输入的字符串以指定的重复次数拼接后返回</span></span><br><span class="line">fmt.Println(strings.Repeat(b, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>ThreeREyeDThreeREyeDThreeREyeD</p></blockquote><p><strong>（9）func Replace(s, old, new string, n int) string</strong></p><p>返回字符串s前n个不重复old子串替换为new子串的新字符串；n&lt;0替换所有old子串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换字符串中的子字符串，当替换次数小于0的时候替换所有的子字符串</span></span><br><span class="line">fmt.Println(strings.Replace(b, <span class="string">"e"</span>, <span class="string">"T"</span>, <span class="number">1</span>))</span><br><span class="line">fmt.Println(strings.Replace(b, <span class="string">"e"</span>, <span class="string">"T"</span>, <span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>ThrTeREyeD<br>ThrTTREyTD</p></blockquote><p><strong>（10）func Trim(s string, cutset string) string</strong></p><p>返回去掉字符串s前后端所有cutset子串的字符串</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="string">"eeeTRsaeAAAeweee"</span></span><br><span class="line"><span class="comment">// 去掉字符串两边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.Trim(c, <span class="string">"eee"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>TRsaeAAAew</p></blockquote><p><strong>（11）func TrimSpace(s string) string</strong></p><p>返回去掉字符串s前后端空白字符（unicode.IsSpace指定）的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d := <span class="string">"   eeeTRsaeAAAeweee   "</span></span><br><span class="line"><span class="comment">// 去掉字符串两边的空白符</span></span><br><span class="line">fmt.Println(strings.TrimSpace(d))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>eeeTRsaeAAAeweee</p></blockquote><p><strong>（12）func TrimLeft(s string, cutset string) string</strong></p><p>返回去掉字符串s前端所有cutset子串的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e := <span class="string">"aaayxseryewerrrr"</span></span><br><span class="line"><span class="comment">// 去掉字符串左边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimLeft(e, <span class="string">"a"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>yxseryewerrrr</p></blockquote><p><strong>（13）func TrimRight(s string, cutset string) string</strong></p><p>返回去掉字符串s后端所有cutset子串的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉字符串右边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimRight(e, <span class="string">"r"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>aaayxseryewe</p></blockquote><p><strong>（14）func TrimPrefix(s, prefix string) string</strong></p><p>返回去掉字符串s的前缀prefix子串的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉字符串开头的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimPrefix(e, <span class="string">"aaayx"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>seryewerrrr</p></blockquote><p><strong>（15）func TrimSuffix(s, suffix string) string</strong></p><p>返回去掉字符串s的后缀suffix子串的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉字符串结尾的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimSuffix(e, <span class="string">"werrrr"</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>aaayxserye</p></blockquote><p><strong>（16）func Fields(s string) []string</strong></p><p>返回将字符串s按一个或多个空白（unicode.IsSpace）字符分割的多个字符串切片；空白字符串或空字符串返回空切片；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="string">"Hi, Tim, how are you!"</span></span><br><span class="line"><span class="comment">// 将字符串进行切割再返回</span></span><br><span class="line">fmt.Println(strings.Fields(f))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>[Hi, Tim, how are you!]</p></blockquote><p><strong>（17）func Split(s, sep string) []string</strong></p><p>返回将字符串s按一个sep子串分割的字符串切片；sep为空字符串时，将s分割为每一个unicode码值的字符串切片；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g := <span class="string">"just relax and take it easy"</span></span><br><span class="line"><span class="comment">// 将字符串以指定字符串进行切割再返回</span></span><br><span class="line">result := strings.Split(g, <span class="string">" "</span>)</span><br><span class="line">fmt.Printf(<span class="string">"result' type: %T\n"</span>, result)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(result))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>result’ type: []string   // 返回的是一个字符串数组<br>6   // 该数组有6个元素</p></blockquote><p><strong>（18）func Join(a []string, sep string) string</strong></p><p>返回将字符串切片a以子串sep连接的字符串；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拼接字符串</span></span><br><span class="line">h := <span class="string">"I"</span></span><br><span class="line">i := <span class="string">"love"</span></span><br><span class="line">j := <span class="string">"you"</span></span><br><span class="line">fmt.Println(strings.Join([]<span class="keyword">string</span>&#123;h, i, j&#125;, <span class="string">" "</span>))</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>I love you</p></blockquote><p>以上代码省略部分内容，完整代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="string">"threereyed"</span></span><br><span class="line"><span class="comment">// 判断字符串中是否以指定字符串开头</span></span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">"th"</span>))</span><br><span class="line">fmt.Println(strings.HasPrefix(a, <span class="string">"ht"</span>))</span><br><span class="line"><span class="comment">// 判断字符串中是否以指定字符串结尾</span></span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">"ed"</span>))</span><br><span class="line">fmt.Println(strings.HasSuffix(a, <span class="string">"sa"</span>))</span><br><span class="line"><span class="comment">// 判断字符串中是否包含某个字符串</span></span><br><span class="line">fmt.Println(strings.Contains(a, <span class="string">"ree"</span>))</span><br><span class="line"><span class="comment">// 返回字符串中有几个指定的字符串</span></span><br><span class="line">fmt.Println(strings.Count(a, <span class="string">"e"</span>))</span><br><span class="line"><span class="comment">// 返回字符串中指定字符串第一次出现的位置</span></span><br><span class="line">fmt.Println(strings.Index(a, <span class="string">"e"</span>))</span><br><span class="line"></span><br><span class="line">b := <span class="string">"ThreeREyeD"</span></span><br><span class="line"><span class="comment">// 返回转小写后的字符串</span></span><br><span class="line">fmt.Println(strings.ToLower(b))</span><br><span class="line"><span class="comment">// 返回转大写后的字符串</span></span><br><span class="line">fmt.Println(strings.ToUpper(b))</span><br><span class="line"><span class="comment">// 将输入的字符串以指定的重复次数拼接后返回</span></span><br><span class="line">fmt.Println(strings.Repeat(b, <span class="number">3</span>))</span><br><span class="line"><span class="comment">// 替换字符串中的子字符串，当替换次数小于0的时候替换所有的子字符串</span></span><br><span class="line">fmt.Println(strings.Replace(b, <span class="string">"e"</span>, <span class="string">"T"</span>, <span class="number">1</span>))</span><br><span class="line">fmt.Println(strings.Replace(b, <span class="string">"e"</span>, <span class="string">"T"</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">c := <span class="string">"eeeTRsaeAAAeweee"</span></span><br><span class="line"><span class="comment">// 去掉字符串两边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.Trim(c, <span class="string">"eee"</span>))</span><br><span class="line"></span><br><span class="line">d := <span class="string">"   eeeTRsaeAAAeweee   "</span></span><br><span class="line"><span class="comment">// 去掉字符串两边的空白符</span></span><br><span class="line">fmt.Println(strings.TrimSpace(d))</span><br><span class="line"></span><br><span class="line">e := <span class="string">"aaayxseryewerrrr"</span></span><br><span class="line"><span class="comment">// 去掉字符串左边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimLeft(e, <span class="string">"a"</span>))</span><br><span class="line"><span class="comment">// 去掉字符串右边的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimRight(e, <span class="string">"r"</span>))</span><br><span class="line"><span class="comment">// 去掉字符串开头的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimPrefix(e, <span class="string">"aaayx"</span>))</span><br><span class="line"><span class="comment">// 去掉字符串结尾的指定子字符串</span></span><br><span class="line">fmt.Println(strings.TrimSuffix(e, <span class="string">"werrrr"</span>))</span><br><span class="line"></span><br><span class="line">f := <span class="string">"Hi, Tim, how are you!"</span></span><br><span class="line"><span class="comment">// 将字符串进行切割再返回</span></span><br><span class="line">fmt.Println(strings.Fields(f))</span><br><span class="line"></span><br><span class="line">g := <span class="string">"just relax and take it easy"</span></span><br><span class="line"><span class="comment">// 将字符串以指定字符串进行切割再返回</span></span><br><span class="line">result := strings.Split(g, <span class="string">" "</span>)</span><br><span class="line">fmt.Printf(<span class="string">"result' type: %T\n"</span>, result)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(result))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拼接字符串</span></span><br><span class="line">h := <span class="string">"I"</span></span><br><span class="line">i := <span class="string">"love"</span></span><br><span class="line">j := <span class="string">"you"</span></span><br><span class="line">fmt.Println(strings.Join([]<span class="keyword">string</span>&#123;h, i, j&#125;, <span class="string">" "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回：</p><blockquote><p>true<br>false<br>true<br>false<br>true<br>4<br>3<br>threereyed<br>THREEREYED<br>ThreeREyeDThreeREyeDThreeREyeD<br>ThrTeREyeD<br>ThrTTREyTD<br>TRsaeAAAew<br>eeeTRsaeAAAeweee<br>yxseryewerrrr<br>aaayxseryewe<br>seryewerrrr<br>aaayxserye<br>[Hi, Tim, how are you!]<br>result’ type: []string<br>6<br>I love you</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量来源"><a href="#变量来源" class="headerlink" title="变量来源"></a>变量来源</h3><p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。</p><p>变量可以通过变量名访问。</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>一般常用的有，数值型、布尔型、字符串类型、派生类型</p><p>派生类型包括：</p><ul><li>(a) 指针类型（Pointer）</li><li>(b) 数组类型</li><li>(c) 结构化类型(struct)</li><li>(d) Channel 类型</li><li>(e) 函数类型</li><li>(f) 切片类型</li><li>(g) 接口类型（interface）</li><li>(h) Map 类型</li></ul><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><h4 id="第一种方式：指定变量类型，如果没有初始化，则变量默认为零值"><a href="#第一种方式：指定变量类型，如果没有初始化，则变量默认为零值" class="headerlink" title="第一种方式：指定变量类型，如果没有初始化，则变量默认为零值"></a>第一种方式：指定变量类型，如果没有初始化，则变量默认为零值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量的声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span> <span class="comment">// 声明一个变量名为a的变量，其类型为int，值为1</span></span><br><span class="line">fmt.Println(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span> = <span class="string">"threereyed"</span> <span class="comment">// 声明一个变量名为b的变量，其类型为string，值为threereyed</span></span><br><span class="line">fmt.Println(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">fmt.Println(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不给变量设置值则默认为零值</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">int</span></span><br><span class="line">fmt.Println(d)</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">string</span></span><br><span class="line">fmt.Println(e)</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">bool</span></span><br><span class="line">fmt.Println(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的输出为：</p><blockquote><p>D:\Go\src\github.com\ThreeREyed\studygo\day02&gt;go run main.go<br>1<br>threereyed<br>true<br>0</p><p>false</p></blockquote><h4 id="第二种，根据值自行判定变量类型"><a href="#第二种，根据值自行判定变量类型" class="headerlink" title="第二种，根据值自行判定变量类型"></a>第二种，根据值自行判定变量类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据值来判断类型</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="string">"threereyed"</span></span><br><span class="line">fmt.Println(g, h)</span><br></pre></td></tr></table></figure><p>以上代码的输出为：</p><blockquote><p>20 threereyed</p></blockquote><h4 id="第三种，省略-var，-，-只在函数中体现（短变量声明）"><a href="#第三种，省略-var，-，-只在函数中体现（短变量声明）" class="headerlink" title="第三种，省略 var，:= ， 只在函数中体现（短变量声明）"></a>第三种，省略 var，:= ， 只在函数中体现（短变量声明）</h4><p><strong>注意 \</strong>:=** 左侧如果没有声明新的变量，就产生编译错误**</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据值来判断类型</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> h = <span class="string">"threereyed"</span></span><br><span class="line">fmt.Println(g, h)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略var 使用:= 的方式来声明，:= 左侧必须是有新的变量产生</span></span><br><span class="line">i := <span class="number">30</span></span><br><span class="line">g := <span class="number">40</span> <span class="comment">// 此时产生编译错误no new variables on left side of :=go</span></span><br><span class="line">g, j := <span class="number">40</span>, <span class="number">50</span> <span class="comment">// 因为左侧有新的变量声明，所以不会有编译错误</span></span><br></pre></td></tr></table></figure><h4 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">// 和 python 很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">string</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。</p><p>如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。</p><p>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误</p><p>但是全局变量是<strong>允许声明但不使用</strong>。</p><p>同一类型的多个变量可以声明在同一行</p><h2 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h2><h3 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h3><p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</p><p><strong>驼峰命名</strong></p><p>大驼峰（eg: ThreeEyed），小驼峰(threeEyed)</p><p><strong>下划线连接</strong></p><p>eg: three_eyed</p><p>匿名变量 <code>-</code></p><p>空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。</p><p>_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。 </p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是一个简单值的标识符，在程序运行过程中，不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p><strong>关键字<code>const</code></strong></p><h3 id="常量声明方式"><a href="#常量声明方式" class="headerlink" title="常量声明方式"></a>常量声明方式</h3><p><strong>声明单个常量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure><p>你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p><ul><li>显式类型定义： <code>const b string = &quot;abc&quot;</code></li><li>隐式类型定义： <code>const b = &quot;abc&quot;</code></li></ul><p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过</p><p><strong>单行声明常量</strong></p><p>多个相同类型的声明可以简写为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c_name1, c_name2 = value1, value2</span><br></pre></td></tr></table></figure><p><strong>批量声明常量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conset &#123;</span><br><span class="line">name1 <span class="keyword">string</span></span><br><span class="line">name2 <span class="keyword">bool</span></span><br><span class="line">name3 <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">name1 = <span class="number">1</span></span><br><span class="line">name2</span><br><span class="line">name3</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(name1, name2, name3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>const 批量声明常量时，如果没有被赋值，那么上一行的值会赋给下一行没有赋值的常量，以上代码输出内容为</p><blockquote><p>1 1 1</p></blockquote><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><h4 id="常量计数器"><a href="#常量计数器" class="headerlink" title="常量计数器"></a>常量计数器</h4><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p><p>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="literal">iota</span></span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> d = <span class="literal">iota</span></span><br><span class="line"><span class="keyword">const</span> e = <span class="literal">iota</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(a, b, c, d, e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出为：</p><blockquote><p>0 1 2 0 0</p></blockquote><p>批量声明中的iota 随着常量增加而增加，但是const 再出现时，iota 被重新设置为0</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">"ha"</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//"ha"   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出为：</p><blockquote><p>0  1 2 ha ha 100 100 7 8</p></blockquote><p>充分说明iota 是一个常量计数器</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    i=<span class="number">1</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    j=<span class="number">3</span>&lt;&lt;<span class="literal">iota</span></span><br><span class="line">    k</span><br><span class="line">    l</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"i="</span>,i)</span><br><span class="line">    fmt.Println(<span class="string">"j="</span>,j)</span><br><span class="line">    fmt.Println(<span class="string">"k="</span>,k)</span><br><span class="line">    fmt.Println(<span class="string">"l="</span>,l)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例运行结果为：</p><blockquote><p>i= 1<br>j= 6<br>k= 12<br>l= 24</p></blockquote><p>iota 表示从 0 开始自动加 1，所以 <strong>i=1&lt;&lt;0</strong>, <strong>j=3&lt;&lt;1</strong>（<strong>&lt;&lt;</strong> 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 <strong>k=3&lt;&lt;2</strong>，<strong>l=3&lt;&lt;3</strong>。</p><p>简单表述:</p><ul><li><p>i=1</p></li><li><p>：左移 0 位,不变仍为 1;</p></li><li><p><strong>j=3</strong>：左移 1 位,变为二进制 110, 即 6;</p></li><li><p><strong>k=3</strong>：左移 2 位,变为二进制 1100, 即 12;</p></li><li><p><strong>l=3</strong>：左移 3 位,变为二进制 11000,即 24。</p></li></ul><h4 id="用来定义数量级"><a href="#用来定义数量级" class="headerlink" title="用来定义数量级"></a>用来定义数量级</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">_  = <span class="literal">iota</span></span><br><span class="line">KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">PB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意：</p><p><code>&lt;&lt;n == *(2^n)</code></p><p>左移运算符 <strong>&lt;&lt;</strong> 是双目运算符。左移 n 位就是乘以 2 的 n 次方。 其功能把 <strong>&lt;&lt;</strong> 左边的运算数的各二进位全部左移若干位，由 <strong>&lt;&lt;</strong> 右边的数指定移动的位数，高位丢弃，低位补 0。</p><p>右移运算符 <strong>&gt;&gt;</strong> 是双目运算符。右移 n 位就是除以 2 的 n 次方。 其功能是把 <strong>&gt;&gt;</strong> 左边的运算数的各二进位全部右移若干位， <strong>&gt;&gt;</strong> 右边的数指定移动的位数。</p><div class="note warning">            <p>本节部分内容引自<a href="https://www.runoob.com/go/go-variables.html" target="_blank" rel="noopener">菜鸟教程</a> <a href="https://www.liwenzhou.com/posts/Go/01_var_and_const/" target="_blank" rel="noopener">李文周的博客</a></p>          </div>]]></content>
    
    <summary type="html">
    
      Go语言基础之数据类型、变量、常量
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/go-basics/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言基础学习day01（环境搭建）</title>
    <link href="http://threereyed.top/go-basics/Go-basics-day01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day01/"/>
    <id>http://threereyed.top/go-basics/Go-basics-day01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0day01/</id>
    <published>2020-05-20T14:17:49.000Z</published>
    <updated>2020-05-29T08:08:35.579Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>每天记录一点点之go语言基础学习第一天</strong></p><h2 id="Golang的环境搭建"><a href="#Golang的环境搭建" class="headerlink" title="Golang的环境搭建"></a>Golang的环境搭建</h2><ol><li>go下载</li><li>配置环境变量</li></ol><p>可参考大佬博客 <a href="https://www.liwenzhou.com/posts/Go/install_go_dev/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/install_go_dev/</a></p><h2 id="ide-下载"><a href="#ide-下载" class="headerlink" title="ide 下载"></a>ide 下载</h2><p>go语言支持utf-8编码，只要能支持utf-8编码的都可以写go程序，</p><p>一般使用Goland、Vs code、Sublime，Goland 大型项目使用，但是容易卡顿，JB的软件大都这样，Vs code需要自己下载插件来用</p><h2 id="Go-工程目录"><a href="#Go-工程目录" class="headerlink" title="Go 工程目录"></a>Go 工程目录</h2><p><img src="https://i.loli.net/2020/05/23/fXzDQRLnVgy7AO6.png" alt=""></p><h2 id="第一个go程序"><a href="#第一个go程序" class="headerlink" title="第一个go程序"></a>第一个go程序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><p> go的所有文件都需要指定包，包有两种类型，一种是 <strong>main</strong> 包，使用 <code>package main</code> 在代码的最前面声明。另外一种就是 <strong>非main</strong> 包，使用 <code>package</code>  + <code>包名</code> 。main 包的可以有唯一的一个 main 函数，这个函数也是程序的入口。也只有 main 包可以编译成可执行的文件。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><code>import &quot;fmt&quot;</code>：最常用的一种形式</p><p><code>import &quot;./test&quot;</code>：导入同一目录下test包中的内容</p><p><code>import f &quot;fmt&quot;</code>：导入fmt，并给他启别名ｆ</p><p><code>import . &quot;fmt&quot;</code>：将fmt启用别名”.”，这样就可以直接使用其内容，而不用再添加ｆｍｔ，如fmt.Println可以直接写成Println</p><p><code>import _ &quot;fmt&quot;</code> ：表示不使用该包，而是只是使用该包的init函数，并不显示的使用该包的其他内容。注意：这种形式的import，当import时就执行了fmt包中的init函数，而不能够使用该包的其他函数。</p><p><code>import (&quot;fmt&quot;)</code> 也可以这么写</p><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>程序的入口</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul><li><p><code>go build</code> ：程序写完之后使用go build 进行编译，编译完成后生成可执行文件（windows下为后缀为.exe 的文件）</p></li><li><p><code>go install</code>:  go install 执行了两个步骤，先执行go build 再将生成的可执行文件拷贝到go path 的bin目录下</p></li><li><p><code>go build -o 文件名</code> :  -o 可以重新指定文件名 </p></li><li><p><code>go run</code>:  执行脚本文件</p></li><li><p>交叉编译：</p><p>在windows下可以编译在linux平台执行的文件</p><p>只需要指定目标操作系统的平台和处理器架构即可：</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">&gt;SET GOOS=linux  // 目标平台是linux</span><br><span class="line">&gt;SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure><p><em>使用了cgo的代码是不支持跨平台编译的</em></p><p>然后再执行<code>go build</code>命令，得到的就是能够在Linux平台运行的可执行文件了。</p></blockquote></li></ul><h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>编译之后点击可执行文件既可以运行程序</p>]]></content>
    
    <summary type="html">
    
      Go语言基础学习day01之环境搭建
    
    </summary>
    
    
      <category term="Go语言基础" scheme="http://threereyed.top/categories/go-basics/"/>
    
    
      <category term="go" scheme="http://threereyed.top/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Windows下PyCharm的基本快捷键</title>
    <link href="http://threereyed.top/python/pycharm%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://threereyed.top/python/pycharm%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2018-05-21T06:14:59.000Z</published>
    <updated>2020-06-02T08:21:44.103Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Windows下Python-IDE-PyCharm的基本快捷键"><a href="#Windows下Python-IDE-PyCharm的基本快捷键" class="headerlink" title="Windows下Python IDE PyCharm的基本快捷键"></a>Windows下Python IDE PyCharm的基本快捷键</h1><br/><h3 id="编辑（Editing"><a href="#编辑（Editing" class="headerlink" title="编辑（Editing)"></a>编辑（Editing)</h3><ul><li>Ctrl + Space 基本的代码完成（类、方法、属性）</li><li>Ctrl + Alt + Space 快速导入任意类</li><li>Ctrl + Shift + Enter 语句完成</li><li>Ctrl + P 参数信息（在方法中调用参数）</li><li>Ctrl + Q 快速查看文档</li><li>Shift + F1 外部文档</li><li>Ctrl + 鼠标 简介</li><li>Ctrl + F1 显示错误描述或警告信息</li><li>Alt + Insert 自动生成代码</li><li>Ctrl + O 重新方法</li><li>Ctrl + Alt + T 选中</li><li>Ctrl + / 行注释</li><li>Ctrl + Shift + / 块注释</li><li>Ctrl + W 选中增加的代码块</li><li>Ctrl + Shift + W 回到之前状态</li><li>Ctrl + Shift + ]/[ 选定代码块结束、开始</li><li>Alt + Enter 快速修正</li><li>Ctrl + Alt + L 代码格式化</li><li>Ctrl + Alt + O 优化导入</li><li>Ctrl + Alt + I 自动缩进</li><li>Tab / Shift + Tab 缩进、不缩进当前行</li><li>Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板</li><li>Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板</li><li>Ctrl+V/Shift+Insert 从剪贴板粘贴</li><li>Ctrl + Shift + V 从最近的缓冲区粘贴</li><li>Ctrl + D 复制选定的区域或行</li><li>Ctrl + Y 删除选定的行</li><li>Ctrl + Shift + J 添加智能线</li><li>Ctrl + Enter 智能线切割</li><li>Shift + Enter 另起一行</li><li>Ctrl + Shift + U 在选定的区域或代码块间切换</li><li>Ctrl + Delete 删除到字符结束</li><li>Ctrl + Backspace 删除到字符开始</li><li>Ctrl + Numpad+/- 展开折叠代码块</li><li>Ctrl + Numpad+ 全部展开</li><li>Ctrl + Numpad- 全部折叠</li><li>Ctrl + F4 关闭运行的选项卡</li></ul><h3 id="查找-替换-Search-Replace"><a href="#查找-替换-Search-Replace" class="headerlink" title="查找/替换(Search/Replace)"></a>查找/替换(Search/Replace)</h3><ul><li>F3 下一个</li><li>Shift + F3 前一个</li><li>Ctrl + R 替换</li><li>Ctrl + Shift + F 全局查找</li><li>Ctrl + Shift + R 全局替换</li></ul><h3 id="运行-Running"><a href="#运行-Running" class="headerlink" title="运行(Running)"></a>运行(Running)</h3><ul><li>Alt + Shift + F10 运行模式配置</li><li>Alt + Shift + F9 调试模式配置</li><li>Shift + F10 运行</li><li>Shift + F9 调试</li><li>Ctrl + Shift + F10 运行编辑器配置</li><li>Ctrl + Alt + R 运行manage.py任务</li></ul><h3 id="调试-Debugging"><a href="#调试-Debugging" class="headerlink" title="调试(Debugging)"></a>调试(Debugging)</h3><ul><li>F8 跳过</li><li>F7 进入</li><li>Shift + F8 退出</li><li>Alt + F9 运行游标</li><li>Alt + F8 验证表达式</li><li>Ctrl + Alt + F8 快速验证表达式</li><li>F9 恢复程序</li><li>Ctrl + F8 断点开关</li><li>Ctrl + Shift + F8 查看断点</li></ul><h3 id="导航-Navigation"><a href="#导航-Navigation" class="headerlink" title="导航(Navigation)"></a>导航(Navigation)</h3><ul><li>Ctrl + N 跳转到类</li><li>Ctrl + Shift + N 跳转到符号</li><li>Alt + Right/Left 跳转到下一个、前一个编辑的选项卡</li><li>F12 回到先前的工具窗口</li><li>Esc 从工具窗口回到编辑窗口</li><li>Shift + Esc 隐藏运行的、最近运行的窗口</li><li>Ctrl + Shift + F4 关闭主动运行的选项卡</li><li>Ctrl + G 查看当前行号、字符号</li><li>Ctrl + E 当前文件弹出</li><li>Ctrl+Alt+Left/Right 后退、前进</li><li>Ctrl+Shift+Backspace 导航到最近编辑区域</li><li>Alt + F1 查找当前文件或标识</li><li>Ctrl+B / Ctrl+Click 跳转到声明</li><li>Ctrl + Alt + B 跳转到实现</li><li>Ctrl + Shift + I查看快速定义</li><li>Ctrl + Shift + B跳转到类型声明</li><li>Ctrl + U跳转到父方法、父类</li><li>Alt + Up/Down跳转到上一个、下一个方法</li><li>Ctrl + ]/[跳转到代码块结束、开始</li><li>Ctrl + F12弹出文件结构</li><li>Ctrl + H类型层次结构</li><li>Ctrl + Shift + H方法层次结构</li><li>Ctrl + Alt + H调用层次结构</li><li>F2 / Shift + F2下一条、前一条高亮的错误</li><li>F4 / Ctrl + Enter编辑资源、查看资源</li><li>Alt + Home显示导航条F11书签开关</li><li>Ctrl + Shift + F11书签助记开关</li><li>Ctrl + #[0-9]跳转到标识的书签</li><li>Shift + F11显示书签</li></ul><h3 id="搜索相关-Usage-Search"><a href="#搜索相关-Usage-Search" class="headerlink" title="搜索相关(Usage Search)"></a>搜索相关(Usage Search)</h3><ul><li>Alt + F7/Ctrl + F7文件中查询用法</li><li>Ctrl + Shift + F7文件中用法高亮显示</li><li>Ctrl + Alt + F7显示用法</li></ul><h3 id="重构-Refactoring"><a href="#重构-Refactoring" class="headerlink" title="重构(Refactoring)"></a>重构(Refactoring)</h3><ul><li>F5复制F6剪切</li><li>Alt + Delete安全删除</li><li>Shift + F6重命名</li><li>Ctrl + F6更改签名</li><li>Ctrl + Alt + N内联</li><li>Ctrl + Alt + M提取方法</li><li>Ctrl + Alt + V提取属性</li><li>Ctrl + Alt + F提取字段</li><li>Ctrl + Alt + C提取常量</li><li>Ctrl + Alt + P提取参数</li></ul><h3 id="控制VCS-Local-History"><a href="#控制VCS-Local-History" class="headerlink" title="控制VCS/Local History"></a>控制VCS/Local History</h3><ul><li>Ctrl + K提交项目</li><li>Ctrl + T更新项目</li><li>Alt + Shift + C查看最近的变化</li><li>Alt + BackQuote(‘)VCS快速弹出</li></ul><h3 id="模版-Live-Templates"><a href="#模版-Live-Templates" class="headerlink" title="模版(Live Templates)"></a>模版(Live Templates)</h3><ul><li>Ctrl + Alt + J当前行使用模版</li><li>Ctrl +Ｊ插入模版</li></ul><h3 id="基本-General"><a href="#基本-General" class="headerlink" title="基本(General)"></a>基本(General)</h3><ul><li>Alt + #[0-9]打开相应的工具窗口</li><li>Ctrl + Alt + Y同步</li><li>Ctrl + Shift + F12最大化编辑开关</li><li>Alt + Shift + F添加到最喜欢</li><li>Alt + Shift + I根据配置检查当前文件</li><li>Ctrl + BackQuote(‘)快速切换当前计划</li><li>Ctrl + Alt + S　打开设置页</li><li>Ctrl + Shift + A查找编辑器里所有的动作</li><li>Ctrl + Tab在窗口间进行切换</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="python" scheme="http://threereyed.top/categories/python/"/>
    
    
      <category term="pycharm" scheme="http://threereyed.top/tags/pycharm/"/>
    
  </entry>
  
</feed>
